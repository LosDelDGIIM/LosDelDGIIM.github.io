\documentclass[12pt]{article}

\input{../../_assets/preambulo.tex}


\begin{document}

    % 1. Foto de fondo
    % 2. Título
    % 3. Encabezado Izquierdo
    % 4. Color de fondo
    % 5. Coord x del titulo
    % 6. Coord y del titulo
    % 7. Fecha

    
    \input{../../_assets/portada}
    \portadaExamen{etsiitA4.jpg}{Sistemas\\ Concurrentes y\\ Distribuidos\\Examen II}{SCD\@. Examen II}{MidnightBlue}{-8}{28}{2024}{losdelgiim}

    \begin{description}
        \item[Asignatura] Sistemas Concurrentes y Distribuidos.
        \item[Curso Académico] 2024-25.
        \item[Grupo] GII-ADE-M.
        \item[Descripción] Examen parcial de los Temas 1, 2 de SCD.
        \item[Fecha] 03-12-2025.
    \end{description}
    \newpage


    % ------------------------------------
    
    \begin{ejercicio}[3.5 puntos]
        Preguntas de respuestas alternativas: %Poner enlace
        Cada opción correcta suma (0,1). Dos preguntas erróneas anulan 1 correctamente respondida.
    \end{ejercicio}

    \newpage
    \setcounter{ejercicio}{0} % Reiniciar contador de ejercicios

    \textbf{Resolución de problemas: 65$\%$} \footnote{Solo había que resolver 2 ejercicios y el otro podía mejorar la calificación.}
    
    \begin{ejercicio}
        Considérese el siguiente programa concurrente, donde cada instrucción entre < y > se ejecuta de 
        forma atómica: 
        \begin{equation}
            \{x == 0 \land y == 0 \land n > 0\}
        \end{equation}

        \begin{lstlisting}[basicstyle=\ttfamily, frame=single, mathescape=true]
            cobegin
            < x = x + 1 > ||
            while (y < n) do
            begin
                < y = y + 1 >;
            end
            coend
            ${x == 1 \wedge y == n}$ 
        \end{lstlisting}

        Se pide:
        \begin{enumerate}[(label=(\alph*)]
            \item Determinar si el triple de Hoare $\{x == 0 \land y == 0 \land n > 0\}P\{x == 1 \land y == n\}$ concurrente es 
            demostrable usando la Lógica de Programas (incluyendo las reglas del while y la regla de composición concurrente).
            \item En caso afirmativo, construir una demostración completa, indicando:
            \begin{itemize}
                \item El invariante del bucle while.
                \item Las triples atómicas utilizadas.
                \item Las triples resultantes de combinar cada proceso mediante: la regla de composición secuencial, la 
                \item regla de composición iterativa (para el bucle), y la regla de composición concurrente.
            \end{itemize}

            \item Discutir si existe interferencia entre los dos procesos. En particular, justificar si el proceso del bucle puede invalidar las aserciones sobre x 
            (o viceversa) según las reglas de interferencia de Hoare para concucrrencia.
            \end{itemize}
        \end{enumerate}

    \end{ejercicio}

    \begin{ejercicio}
        Se diseña una solución de exclusión mutua en memoria compartida donde pueden entrar como máximo 
        n procesos simultáneamente en sección crítica, con $n \geq 2$.

        En esta versión: 
        \begin{itemize}
            \item Se debe garantizar una cola FIFO para procesos que esperan cuando el afor está completo.
            \item El cerrojo permite hasta n procesos dentro, pero la cola usa un único contador protegido.
            \item Al salir un proceso, solo se desbloque a un proceso de la cola, no a todos.
            
            Taresas:
            \begin{itemize}[label=(\alph*)]
                \item Dar pseudocódigo de entrada y salida.
                \item Probar exclusión mutua extendida, ausencia de interbloqueo y equidad.
            \end{itemize}
        \end{itemize}
    \end{ejercicio}

    \begin{ejercicio}
        Se desea un monitor CentroRecursos para gestionar acceso de procesos de tipo 1 y tipo 3 con estas reglas:
        \begin{itemize}[label=(\alph*)]
            \item Solo procesos del mismo tipo pueden estar dentro simultáneamente.
            \item Nunca pueden coincidir procesos de tipos distintos.
            \item Si hay procesos esperando de ambots tipos, tiene prioridad el tipo que haya acumulado más esperas totales.
            \item Al terminar, un proceso despier a uno del tipo con mayor priorida acumulada.
        \end{itemize}

        El monitor exporta: entrar(tipo), salir(tipo).
        Tareas:
        \begin{itemize}[label=(\alph*)]
            \item Diseñar el monitor con variables internas, colas de condición y contradores de espera.
            \item Mostrar cómo se aplica la prioridad dinámica.
            \item Justificar exclusión mutua, ausencia de interbloqueo y no inanición.
        \end{itemize}
    \end{ejercicio}
\end{document}