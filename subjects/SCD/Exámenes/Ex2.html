<!DOCTYPE html>
<html lang="es">
<head>
    <title>LosDelDGIIM | Test</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="UTF-8">

    <link rel="icon" href="../../../../assets/Icon.png">

    
    
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <p><br></p>
<h1>Sistemas Concurrentes y Distribuidos. Examen II.</h1>
<p><strong>Autor:</strong> Ángel Caro Montalbán</p>
<hr>
<ul>
<li><strong>Asignatura:</strong> Sistemas Concurrentes y Distribuidos.</li>
<li><strong>Curso Académico:</strong> 2025-26.</li>
<li><strong>Grado:</strong> GII-ADE-M.</li>
<li><strong>Grupo:</strong> Único.</li>
<li><strong>Profesor:</strong> Manuel Isidoro Capel Tuñón.</li>
<li><strong>Fecha:</strong> 03-12-2025.</li>
<li><strong>Descripción:</strong> Examen Parcial 1 (anulado).</li>
</ul>
<hr>
<ol>
<li>
<p>¿Cuál de las siguientes es una solución para garantizar la corrección de los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Utilizar métodos formales basados en la lógica matemática para verificar la corrección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Confiar sólo en la comprobación manual de errores.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ignorar los errores transitorios porque ocurren raramente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Utilizar la fuerza bruta para reejecutar el programa varias veces.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se puede garantizar la corrección sin ningún método formal.</label></li>
</ul>
</li>
<li>
<p>¿Qué es un Monitor de Barrera Parcial?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un monitor que detiene todos los procesos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un monitor que libera procesos en intervalos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un monitor que bloquea procesos hasta que un grupo alcanza un estado.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un monitor que reduce el tiempo de espera.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un monitor que libera a todos los procesos al mismo tiempo.</label></li>
</ul>
</li>
<li>
<p>¿Qué es la exclusión mutua en concurrencia?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Garantizar que solo un proceso acceda a una sección crítica a la vez.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitir que múltiples procesos accedan simultáneamente a la memoria.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Sincronizar dos procesos sin que uno bloquee al otro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ejecutar procesos en paralelo sin control de acceso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ninguna de las anteriores.</label></li>
</ul>
</li>
<li>
<p>¿Qué significa irrepetibilidad de las secuencias de instrucciones en la programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos siguen siempre la misma secuencia de ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los programas concurrentes nunca tienen errores.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Dos ejecuciones seguirán probablemente el mismo camino.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Los programas concurrentes generan muchos entrelazamientos de instrucciones posibles, por lo que es poco probable que se repitan caminos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La velocidad de ejecución determina la secuencia de instrucciones.</label></li>
</ul>
</li>
<li>
<p>En la versión preferencia a chicas del problema 60 (relación 2-1), si un chico espera y llega una chica:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> pasa el chico.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> pasan los dos si hay aforo.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> la chica tiene prioridad al siguiente hueco.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> nadie pasa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se atiende por orden de llegada.</label></li>
</ul>
</li>
<li>
<p>¿Qué función cumple la operación <code>c.wait()</code> en un monitor?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquear el monitor hasta que se libere.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Disminuir el valor de la variable protegida.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Bloquear al proceso que llama al procedimiento que la ejecuta hasta que se cumpla una condición.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Liberar procesos en la cola de entrada al monitor.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> A veces, puede permitir la sincronización sin bloquear.</label></li>
</ul>
</li>
<li>
<p>¿Qué define el término cliente en un modelo cliente/servidor?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un proceso pasivo que recibe datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un proceso que almacena mensajes.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un proceso activo que solicita servicios.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un proceso intermedio entre servidor y base de datos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un controlador centralizado.</label></li>
</ul>
</li>
<li>
<p>¿Qué es el progreso global en el contexto de la ejecución concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que todos los procesos terminen la ejecución inmediatamente.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza que al menos un proceso listo para ejecutarse llegue a ejecutarse, evitando el bloqueo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere que todos los procesos se ejecuten al mismo tiempo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que ningún proceso pueda bloquear la ejecución de otro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Es específico sólo de los sistemas en tiempo real.</label></li>
</ul>
</li>
<li>
<p>Para evitar interbloqueo en MonFilo (problema 69 (a), relación 2-1) sin árbitro basta con:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> permitir 5 intentos concurrentes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> prohibir la actividad "pensar" de los filósofos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> limitar a 4 filósofos intentando coger su primer tenedor.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> que todos cojan primero el izquierdo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> que todos suelten al terminar de pensar.</label></li>
</ul>
</li>
<li>
<p>En la lógica de Hoare, ¿qué se necesita para verificar la corrección de una composición concurrente de procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Cada proceso debe tener su propio espacio de memoria independiente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La composición sólo debe implicar a un único proceso a la vez.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Las precondiciones y postcondiciones de los procesos deben de poder combinarse, y ningún proceso debe invalidar las afirmaciones de los demás.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos deben ejecutarse secuencialmente, sin solapar instrucciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El sistema debe probarse con todas las configuraciones de hardware posibles.</label></li>
</ul>
</li>
<li>
<p>En el algoritmo de tickets (problema 75, relación 2-2), la ausencia de inanición se apoya en...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> prioridad fija a P1.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> numeración creciente y orden lexicográfico (ticket, id).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> azar del planificador.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> cálculo de prioridad de los procesos en cada iteración del protocolo de entrada.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> incremento secuencial en los valores de las variables.</label></li>
</ul>
</li>
<li>
<p>¿Qué sucede en la semántica de Señalar y Salir (SS)?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> El proceso señalador continúa ejecutando.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El proceso señalado queda en espera.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El proceso señalador sale del monitor después de signal.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se detiene la ejecución del monitor.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El siguiente proceso esperando es liberado inmediatamente.</label></li>
</ul>
</li>
<li>
<p>¿Qué efecto pueden tener las condiciones de carrera en los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Garantizan que todos los procesos se ejecuten de forma predecible.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Producen resultados predecibles y correctos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Producen resultados impredecibles o incorrectos según el orden de ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Reducen el riesgo de errores en el programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Facilitan la depuración debido a su comportamiento coherente.</label></li>
</ul>
</li>
<li>
<p>Si en Dijkstra se cambia (6) por <code>if flag[turno]!=enSC</code> el algoritmo... (algoritmo, página 10):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> mejora equidad.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> pierde corrección (seguridad).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> mantiene EM pero pierde progreso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> mantiene todo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> sólo afecta rendimiento.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes no es una estrategia para evitar el interbloqueo?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Evitar la espera circular.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asignación ordenada de recursos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Suspensión de procesos en espera.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Mantener la CPU libre de cargas excesivas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Utilizar algoritmos de detección y recuperación.</label></li>
</ul>
</li>
<li>
<p>¿Cuál es la principal desventaja de usar espera ocupada para la sincronización entre procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Alto consumo de CPU mientras espera.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No garantiza exclusión mutua.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No son compatibles con sistemas de tiempo real.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquean completamente la ejecución del sistema.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Son incompatibles con los semáforos.</label></li>
</ul>
</li>
<li>
<p>¿Qué reto presentan las trazas de ejecución de los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Siempre conducen a un punto muerto.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Siguen un patrón predecible y repetible.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Generan numerosas secuencias de intercalación posibles, lo que complica la predicción.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Las trazas no pueden utilizarse con fines de depuración.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Las trazas garantizan que se producirán errores.</label></li>
</ul>
</li>
<li>
<p>¿Qué propiedad define el determinismo en los STR?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Ejecutar tareas concurrentes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Predecir con certeza los tiempos de respuesta.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantizar ejecuciones idénticas incluso con concurrencia.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requerir planificación en tiempo real.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Propagar errores transitorios de forma controlada.</label></li>
</ul>
</li>
<li>
<p>En el esquema <code>s[i]</code> (problema 74, relación 2-2), la estructura implementa...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> un anillo token que garantiza equidad por rotación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> prioridad fija del proceso 0.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> acceso aleatorio.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> bloqueo del resto de los procesos que no acceden a SC en la ronda actual.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> dos tokens simultáneos.</label></li>
</ul>
</li>
<li>
<p>¿Qué son los errores transitorios en el contexto de los programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Errores que aparecen siempre en la misma ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Errores que se producen aleatoriamente y no tienen solución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Errores que son fáciles de detectar y solucionar.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Errores que aparecen en algunas ejecuciones pero no en otras, lo que dificulta su detección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Errores que nunca se producen en los programas concurrentes.</label></li>
</ul>
</li>
<li>
<p>¿Qué problema ocurre cuando múltiples procesos intentan modificar una variable compartida al mismo tiempo?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Fragmentación de memoria.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Condiciones de carrera.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Overhead de comunicación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Pérdida de coherencia en caché.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Errores de compilación.</label></li>
</ul>
</li>
<li>
<p>¿Qué condición de Dijkstra no es esencial para la exclusión mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Mayor escalabilidad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Menor latencia en comunicación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Tolerancia a fallos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Distribución de carga.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Independencia de ubicación.</label></li>
</ul>
</li>
<li>
<p>¿Qué proceso controla la sincronización en un sistema productor-consumidor?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Productor.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Consumidor.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Búfer intermedio.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Coordinador externo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cliente.</label></li>
</ul>
</li>
<li>
<p>¿Qué es una traza en el contexto de la programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Una secuencia de operaciones atómicas de un único proceso.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una secuencia de estados del programa producidos por un intercalado específico de instrucciones.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La ejecución de un único proceso de forma aislada.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El historial de cómo se modifican las variables durante la compilación.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un registro de todos los errores en la ejecución de un programa.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes soluciones no es una técnica eficaz para exclusión mutua en memoria compartida?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Semáforos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Monitores.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Algoritmo de Lamport.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cerrojos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Espera ocupada.</label></li>
</ul>
</li>
<li>
<p>En el algoritmo de Dijkstra, ¿qué ocurre si varios procesos intentan entrar a la sección crítica al mismo tiempo?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Solo uno entra y los demás esperan.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos entran simultáneamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se produce una condición de carrera.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Se usa un mecanismo de prioridad para decidir.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se activa un interbloqueo.</label></li>
</ul>
</li>
<li>
<p>¿Cuál es la principal desventaja de usar espera ocupada para la sincronización entre procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Alto consumo de CPU mientras espera.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No garantizan exclusión mutua.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No son compatibles con sistemas de tiempo real.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquean completamente la ejecución del sistema.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Son incompatibles con los semáforos.</label></li>
</ul>
</li>
<li>
<p>¿Qué es un monitor en programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un dispositivo de entrada de datos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un mecanismo de programación que permite sincronización de procesos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un programa antivirus.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una interfaz gráfica de usuario.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un controlador de semáforos.</label></li>
</ul>
</li>
<li>
<p>¿Qué implica la independencia de la velocidad del proceso en la programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La corrección del proceso debe depender de la velocidad relativa de los procesos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> La corrección del proceso debe ser independiente de la velocidad de ejecución, evitando las condiciones de carrera.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos deben ejecutarse siempre lo más rápido posible.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos más lentos garantizan una mayor estabilidad del programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La velocidad de ejecución siempre determina la corrección del programa.</label></li>
</ul>
</li>
<li>
<p>¿En qué situación es preferible usar monitores en vez de semáforos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Cuando se requiere encapsulación de los mecanismos de sincronización.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuando se manejan múltiples hilos con prioridad variable.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuando se necesita garantizar exclusión mutua sin ocupación innecesaria de CPU.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cuando los procesos deben ejecutarse en sistemas distribuidos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Solo en sistemas de tiempo real.</label></li>
</ul>
</li>
<li>
<p>En Filósofos comensales con monitor MonFilo (problema 69, relación 2-1), una solución clásica que sí puede interbloquear es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> coger siempre primero el tenedor de menor índice.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> permitir que los 5 cojan su primer tenedor simultáneamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> permitir que 4 filósofos o más intenten coger su primer tenedor.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> usar un árbitro que concede permisos y cuenta los tenedores que queda libres.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> asimetría en el orden de tomar tenedores.</label></li>
</ul>
</li>
<li>
<p>¿Qué condición de Dijkstra no es esencial para la exclusión mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> No hacer suposiciones sobre la velocidad de los procesos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Cada proceso debe tener un identificador único.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si un proceso está fuera de la sección crítica, no impide a otros entrar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Algún proceso en espera debe entrar en la sección crítica.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La concurrencia es siempre determinista.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de los siguientes no es un problema asociado a la concurrencia?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Interbloqueo (Deadlock).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inanición (Starvation).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Condiciones de carrera.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Fragmentación de memoria.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Indeterminismo.</label></li>
</ul>
</li>
<li>
<p>¿Cuál es la principal característica de la regla de no interferencia de la lógica de Hoare para programas concurrentes?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que cada proceso termina de ejecutarse antes de que comience el siguiente.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza que dos procesos no interfieran entre sí en sus precondiciones y postcondiciones cuando se ejecutan simultáneamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite que los procesos se ejecuten sin sincronización y sigue garantizando la corrección.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que las precondiciones y poscondiciones de las instrucciones no se vean modificadas por otros procesos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que todos los procesos accedan a los recursos compartidos al mismo tiempo.</label></li>
</ul>
</li>
<li>
<p>En la versión (b): por orden de llegada al banco del problema 66 (relación 2-1), si el primero pide 300 y <code>saldo = 200</code>:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> se atiende al segundo si pide \(\leq 200\).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> todos esperan hasta que el primero pueda cobrar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se divide el saldo entre los dos.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se atiende al segundo y se mantiene al primero esperando.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> cancela la petición del primero.</label></li>
</ul>
</li>
<li>
<p>En un monitor, aunque la exclusión mutua está garantizada, se exige que los procedimientos sean reentrantes porque:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> la semántica SU prohíbe <code>signal()</code> dentro del monitor.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> los procesos pueden bloquearse y reentrar al monitor tras un <code>wait()/signal()</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> la entrada al monitor es no determinista.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se permite invocar el mismo procedimiento desde llamadas asíncronas.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> reentrancia evita el interbloqueo por definición.</label></li>
</ul>
</li>
<li>
<p>¿Qué significa progreso local en la programación concurrente?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Una vez que un proceso empieza a ejecutar una sección de código, debe completarla sin interrupción.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un proceso puede detenerse a mitad de ejecución y reanudarse más tarde sin completar la sección actual.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un proceso debe completar siempre todo el programa sin pausa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos deben comunicarse con otros procesos para continuar la ejecución.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una vez que un proceso comienza a ejecutarse, debe terminar todo el programa.</label></li>
</ul>
</li>
<li>
<p>El algoritmo de Knuth N procesos cumple...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> no garantiza EM.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> EM, alcanzabilidad, vivacidad y equidad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> requiere que se cumpla la propiedad de equidad (fairness) fuerte.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> sólo EM y alcanzabilidad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> la vivacidad, que no cumplía el algoritmo de Dijkstra.</label></li>
</ul>
</li>
<li>
<p>La extensión del protocolo de la exclusión mutua con "como mucho n procesos en SC", una solución correcta se basa en:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> un ticket lock clásico.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> un semáforo contador inicializado a <code>n</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> una variable booleana <code>turn</code>.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> dos flags por proceso.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> un árbol binario de Peterson.</label></li>
</ul>
</li>
<li>
<p>En Dijkstra N procesos, la proposición sobre quien asigna turno en último lugar es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> verdadera.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> falsa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> verdadera si FIFO.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> verdadera si SU.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> depende de N.</label></li>
</ul>
</li>
<li>
<p>La solución de Hyman (1966) a EM para 2 procesos (problema 73, relación 2-2) es:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> correcta.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> incorrecta.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> correcta sólo si se cumple equidad (fairness) fuerte.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> correcta si \(c_0, c_1\) boolean.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> correcta si \(turno = -1\).</label></li>
</ul>
</li>
<li>
<p>¿Qué sucede con un proceso en cola cuando se usa signal en una semántica SC?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se despierta y sale inmediatamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permanece bloqueado indefinidamente.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Se mueve a la cola de entrada del monitor.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Compite por entrar a la cola del monitor.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ignora la operación signal.</label></li>
</ul>
</li>
<li>
<p>¿Qué significa el triple \(\{P\}C\{Q\}\) en el contexto de la lógica de Hoare?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Si el programa \(C\) se ejecuta, siempre terminará.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Si el programa \(C\) comienza en un estado en el que \(P\) es verdadero, entonces \(Q\) será verdadero después de que \(C\) termine de ejecutarse.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> \(P\) y \(Q\) son variables que representan el estado antes y después de \(C\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Garantiza que en la ejecución de varios procesos contenidos en \(C\) no existen interferencias.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Si el programa \(C\) se ejecuta con la máxima velocidad, \(P\) siempre será igual a \(Q\).</label></li>
</ul>
</li>
<li>
<p>En el algoritmo de tickets \(n1/n2\) (problema 75, relación 2-2) con desempate a favor de P1, garantiza...</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> EM, ausencia de interbloqueo y equidad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> sólo EM y vivacidad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> sólo ausencia de interbloqueo.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ausencia de inanición y alcanzabilidad.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> ninguna.</label></li>
</ul>
</li>
<li>
<p>¿Qué es una cola de prioridad en monitores?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Una cola para ejecutar en último lugar.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una cola que permite ordenar procesos según su menor índice.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una lista de operaciones de señal.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una cola ordenada de procesos suspendidos según un valor estático de una variable.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un tipo de cola prioritaria que reordena los procesos según los valores de una variable permanente del monitor.</label></li>
</ul>
</li>
<li>
<p>¿Cuál de las siguientes es la definición de propiedad de vivacidad?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Una condición que debe cumplirse en cada instante de la ejecución del programa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una propiedad que garantiza que los procesos pueden pausarse indefinidamente.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una condición que establece que algo bueno debe suceder eventualmente en el futuro.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una propiedad que define cuántos procesos pueden ejecutarse simultáneamente.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una condición que establece que nada malo va a pasar en el futuro.</label></li>
</ul>
</li>
<li>
<p>En el ejercicio del baño (preferencia a chicos), problema 60 (relación 2-1) si una chica espera y llega un chico:</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> pasa la chica.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> pasan ambos.</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> pasa el chico antes.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> se alternan.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> nadie pasa hasta que se vacíe, pero pasa antes el chico que espera.</label></li>
</ul>
</li>
<li>
<p>Por qué no se puede demostrar la corrección del siguiente fragmento concurrente a menos que se cumpla \(\{x==0 \wedge y==0 \wedge z==0\}\) <code>&lt;x=z+a&gt; || &lt;y=x+b&gt;</code> \(\{x==a \wedge (y==b \vee y==a+b) \wedge z==0\}\):</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> \(b=0 \vee a=0\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> \(b=0 \wedge a=0\).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> \(a=0\).</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> para cualquier valor de las variables.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> es siempre indemostrable.</label></li>
</ul>
</li>
<li>
<p>Seleccionar el valor correcto de las 2 variables (\(x\) e \(y\)) tras: <code>int x=5, y=2; cobegin &lt;x=x+y&gt;; &lt;y=x*y&gt;; &lt;x=x-y&gt;; coend;</code>:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(x==7, y==14\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(x==5, y==10\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(x==-7, y==14\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(x==-3, y==10\).</label></li>
</ul>
</li>
<li>
<p>¿Por qué el código \(\{x==0\}\) cobegin <x=x+a>; <x=x+a> coend; \(\{x==2*a\}\) no puede ser demostrado directamente con LP?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Porque la poscondición propuesta \(\{x==2*a\}\) es falsa.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Porque falta incluir la posibilidad de que el valor final sea \(\{x==a\}\).</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Porque al aplicar la regla de inferencia utilizo pre y post-condiciones demasiado débiles.</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Porque tengo que incluir en los asertos el valor del contador de programa.</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="show-answers" class="btn btn-link">Mostrar respuestas correctas</button>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <div class="row">
        <button id="reorder-questions" class="btn btn-link">Orden Inicial y Fijado</button>
    </div>
    <script type="text/javascript">$(function () {
    // Guardar el orden inicial de las preguntas y opciones
    var initialQuestions = [];
    var initialOptions = [];

    // Guardar el orden inicial de las preguntas y opciones al cargar la página
    $('ol').each(function (i, ol) {
        var $ol = $(ol);
        initialQuestions[i] = $ol.children('li').toArray();
    });
    $('ul.radio-list').each(function (i, ul) {
        var $ul = $(ul);
        initialOptions[i] = $ul.children('li').toArray();
    });


    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-warning');
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-warning');
            } else {
                self.removeClass('text-warning'); // Eliminar la marca de respuesta parcialmente correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $(document).on('change', 'li.question-row input', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });

    // Función para mostrar todas las respuestas correctas
    $('#show-answers').on('click', function () {
        $('li.question-row').each(function () {
            var question = $(this);

            // Mostrar respuestas correctas para preguntas de tipo radio
            if (question.hasClass('radio-list')) {
                question.find('input[type="radio"][data-content="1"]').prop('checked', true);
                question.addClass('text-success');
                question.find('input[type="radio"]').attr('disabled', true); // Bloquear inputs
            }

            // Mostrar respuestas correctas para preguntas de tipo checkbox
            if (question.hasClass('checklist')) {
                question.find('input[type="checkbox"][data-content="1"]').prop('checked', true);
                question.addClass('text-success');
                question.find('input[type="checkbox"]').attr('disabled', true); // Bloquear inputs
            }

            // Mostrar respuestas correctas para preguntas de tipo textbox
            if (question.hasClass('textbox')) {
                var textbox = question.find('input[type="text"]');
                var correct_text = String(textbox.data("content")).trim();
                textbox.val(correct_text);
                question.addClass('text-success');
                textbox.attr('disabled', true); // Bloquear inputs
            }
        });
    });

    
    // Función para mezclar las preguntas
    function shuffleQuestions() {
        $('ol').each(function() {
            var ol = $(this);
            var liArr = ol.children('li');
            liArr.sort(function() {
                return (Math.round(Math.random()) - 0.5);
            }).detach().appendTo(ol);
        });
    }

    function shuffleOptions() {
    $('ul.radio-list').each(function() {
        var ul = $(this);
        var liArr = ul.children('li');

        // Verificar si la lista tiene exactamente dos opciones
        if (liArr.length === 2) {
            var options = liArr.map(function() {
                return $(this).text().trim().toLowerCase();
            }).get();

            // Comprobar si las opciones son "verdadero" y "falso" (o "true" y "false")
            if ((options.includes('verdadero') && options.includes('falso')) ||
                (options.includes('v') && options.includes('f')) ||
                (options.includes('t') && options.includes('f')) ||
                (options.includes('Sí') && options.includes('No')) ||
                (options.includes('true') && options.includes('false'))) {
                return; // No mezclar si son Verdadero/Falso
            }
        }

        // Mezclar las opciones si no es un caso de Verdadero/Falso
        liArr.sort(function() {
        return (Math.round(Math.random()) - 0.5);
        }).detach().appendTo(ul);
    });
    }

    // Llamar a las funciones para mezclar las preguntas y las opciones al cargar la página
    shuffleQuestions();
    shuffleOptions();



    // Función para restaurar el orden inicial de preguntas y opciones
    function restoreInitialOrder() {
        // Restaurar preguntas
        $('ol').each(function(i, ol) {
            $(ol).empty();
            $(ol).append(initialQuestions[i]);
        });
        // Restaurar opciones
        $('ul.radio-list').each(function(i, ul) {
            $(ul).empty();
            $(ul).append(initialOptions[i]);
        });
    }
    $('#reorder-questions').on('click', function () {
        restoreInitialOrder();
    });
});</script>
</div>
</body>
</html>