<!DOCTYPE html>
<html lang="es">
<head>
    <title>LosDelDGIIM | Test</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="UTF-8">

    <link rel="icon" href="../../../../assets/Icon.png">

    
    
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <p><br></p>
<h1>SCD. Autoevaluaci贸n del Tema 2. Exclusi贸n Mutua.</h1>
<hr>
<ul>
<li><strong>Asignatura:</strong> Sistemas Concurrentes y Distribuidos.</li>
<li><strong>Curso Acad茅mico:</strong> 2024-25.</li>
<li><strong>Grado:</strong> Doble Grado en Ingenier铆a Inform谩tica y Matem谩ticas.</li>
<li><strong>Grupo:</strong> nico.</li>
<li><strong>Profesor:</strong> Manuel Isidoro Capel Tu帽贸n.</li>
<li><strong>Descripci贸n:</strong> Este documento tiene como objetivo servir para estudiar la asignatura de Sistemas Concurrentes y Distribuidos. En 茅l, se puede encontrar una corta autoevaluaci贸n formada por unas 25 preguntas tipo test sobre la parte de exclusi贸n mutua.</li>
</ul>
<hr>
<ol>
<li>
<p>驴Qu茅 garantiza el algoritmo de Dijkstra para N procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Acceso simult谩neo a la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminaci贸n de la necesidad de turnos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Exclusi贸n mutua con tiempo de espera limitado</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Uso de variables globales compartidas</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exclusi贸n mutua sin control de inanici贸n</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 propiedad NO es garantizada por el algoritmo de Dijkstra?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Uso equitativo de los recursos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Alcanzabilidad de la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Exclusi贸n mutua</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Ausencia de inanici贸n</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Seguridad en el acceso a recursos compartidos</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 representa el turno en un algoritmo de exclusi贸n mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La se帽al para finalizar el programa</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La prioridad fija de un proceso</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> El permiso para acceder a la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La posici贸n en la cola de espera</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> La cantidad de procesos activos en el sistema</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 asegura el algoritmo de Peterson al pasar entre etapas?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La etapa m谩s alta siempre est谩 vac铆a</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos se bloquean indefinidamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El acceso a la secci贸n cr铆tica se distribuye aleatoriamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos siempre progresan de forma equitativa</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Un proceso no avanza s贸lo si no est谩 m谩s adelantado que los dem谩s y es el 煤ltimo en asignar el turno</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 asegura el uso de etapas en el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Interrupci贸n de procesos de bajo nivel</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminaci贸n de etapas redundantes</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Mayor velocidad de procesamiento</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminaci贸n del uso de tokens</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exclusi贸n mutua y equidad</label></li>
</ul>
</li>
<li>
<p>驴Cu谩l es una de las condiciones de Dijkstra para la exclusi贸n mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Un proceso fuera de la secci贸n cr铆tica no debe bloquear a otros procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asignar recursos de manera aleatoria</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Usar variables globales como 煤nica soluci贸n</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos deben ejecutarse secuencialmente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos pueden detenerse indefinidamente</label></li>
</ul>
</li>
<li>
<p>驴C贸mo maneja el algoritmo de Dijkstra las prioridades entre procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Asignando turnos de manera fija</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitiendo que los procesos esperen indefinidamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Usando una cola FIFO</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asignando valores aleatorios a los procesos</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Implementando un contador global de turnos</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 propiedad asegura el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Solo funciona con dos procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Necesita una red de comunicaciones</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza exclusi贸n mutua y evita inanici贸n</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Depende de sem谩foros externos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite acceso prioritario a un proceso</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 significa "progreso finito" en el contexto de Dijkstra? </p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> La ejecuci贸n de un proceso no se interrumpe</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los procesos se ejecutan en paralelo</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos avanzan indefinidamente sin detenerse</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Los procesos tienen un tiempo finito para entrar a la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El acceso a la memoria es constante</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 mejora introduce el algoritmo de Peterson para N procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Sustituye la necesidad de sem谩foros por variables clave locales</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Requiere menos pasos que el algoritmo de Dekker</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permite acceso simult谩neo a la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantiza exclusi贸n mutua para cualquier cantidad de procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Elimina la inanici贸n en sistemas distribuidos</label></li>
</ul>
</li>
<li>
<p>驴C贸mo soluciona el algoritmo de Knuth la inanici贸n en exclusi贸n mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminando los procesos en espera</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitiendo que todos los procesos avancen simult谩neamente</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantizando que el tiempo de espera sea limitado para cada proceso</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Bloqueando procesos con menor prioridad</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Usando turnos circulares para la asignaci贸n de recursos</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 hace un proceso despu茅s de usar la secci贸n cr铆tica en el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Solicita nuevamente el turno</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Env铆a mensajes a otros procesos</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Libera su bandera de "solicitado"</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquea a los otros procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Incrementa un contador global</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 ocurre si dos procesos intentan acceder simult谩neamente en el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Se produce un interbloqueo</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Se respetan las reglas de exclusi贸n mutua</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ambos procesos fallan</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ambos entran a la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Uno de ellos puede quedar bloqueado indefinidamente</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 t茅cnica introduce el algoritmo de Knuth?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Uso de prioridad fija entre procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Uso de sem谩foros para exclusi贸n mutua</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Soluci贸n parcial para sistemas distribuidos</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Retraso limitado en el acceso a la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inanici贸n de procesos</label></li>
</ul>
</li>
<li>
<p>驴C贸mo resuelve el m茅todo de refinamiento sucesivo el problema de exclusi贸n mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminando el uso de turnos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitiendo que dos procesos entren simult谩neamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Usando sem谩foros binarios</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Implementando bucles de espera activa para decidir el acceso</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Dividiendo el problema en m煤ltiples secciones cr铆ticas</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 es una "etapa" en el algoritmo de Peterson para N procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Un mecanismo de exclusi贸n global</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un nivel de prioridad fijo para los procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Un bucle infinito en la ejecuci贸n</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Una fase de sincronizaci贸n antes de la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una se帽al de error en el sistema</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 condici贸n debe cumplirse para que un proceso entre a la secci贸n cr铆tica en el algoritmo de Peterson?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="0" data-content="1" /> Su turno no debe coincidir o la clave del otro proceso debe ser falsa</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su contador debe superar al de los dem谩s procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su clave de solicitud debe ser verdadera</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su prioridad debe ser la m谩s alta</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Su solicitud debe ser la primera en la cola</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 problema puede surgir al verificar las claves en algoritmos de refinamiento sucesivo?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los turnos se asignan de manera inconsistente</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> No se realiza la salida de la espera activa de forma at贸mica</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se producen interrupciones aleatorias</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Bloqueo mutuo al intercambiar turnos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos entran en la secci贸n cr铆tica sin permiso</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 problema intenta resolver la exclusi贸n mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquear indefinidamente todos los procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Evitar el uso de recursos por parte de un proceso</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitir que todos los procesos accedan a la secci贸n cr铆tica simult谩neamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Acelerar el acceso de los procesos a la memoria compartida</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Evitar el acceso simult谩neo de m煤ltiples procesos a una secci贸n cr铆tica</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 ocurre si todos los procesos solicitan acceso simult谩neamente en el algoritmo de Dijkstra?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Los procesos se ordenan en cola de prioridad</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Se produce un interbloqueo</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Uno de ellos accede seg煤n el turno asignado</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> El sistema queda bloqueado indefinidamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos acceden simult谩neamente</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 condici贸n garantiza el algoritmo de Knuth?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Reducci贸n del tiempo de espera a 0</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminaci贸n de procesos en espera</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inanici贸n de procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Interbloqueo constante</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exclusi贸n mutua</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 garantiza el algoritmo de Dekker?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Equidad completa entre procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Inanici贸n de todos los procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Una soluci贸n distribuida</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Ejecuci贸n simult谩nea en la secci贸n cr铆tica</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Exclusi贸n mutua, pero puede causar inanici贸n</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 garantiza la propiedad de equidad en exclusi贸n mutua?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los procesos son bloqueados simult谩neamente</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Todos los procesos avanzan al mismo tiempo</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Solo un proceso ejecuta indefinidamente</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Los procesos acceden en orden sin preferencia indebida</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> No hay necesidad de sincronizaci贸n</label></li>
</ul>
</li>
<li>
<p>驴Qu茅 asegura la verificaci贸n de exclusi贸n mutua en un algoritmo para N procesos?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Bloquear indefinidamente los procesos que esperan</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Garantizar que solo un proceso entre en la secci贸n cr铆tica a la vez</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Asignar recursos de manera aleatoria</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Permitir acceso simult谩neo a m煤ltiples procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Prohibir la entrada de todos los procesos</label></li>
</ul>
</li>
<li>
<p>驴Cu谩l es el principal problema de los bucles de espera activa?</p>
<ul class="radio-list">
<li><label><input type="radio" data-question="1" data-content="0" /> Reducen el tiempo de espera de los procesos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Facilitan la exclusi贸n mutua</label></li>
<li><label><input type="radio" data-question="0" data-content="1" /> Pueden generar uso innecesario de recursos</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Eliminan la necesidad de sincronizaci贸n</label></li>
<li><label><input type="radio" data-question="1" data-content="0" /> Incrementan la equidad del sistema</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <script type="text/javascript">$(function () {
    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-warning');
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-warning');
            } else {
                self.removeClass('text-warning'); // Eliminar la marca de respuesta parcialmente correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $('li.question-row input').on('change', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });

    
    // Funcin para mezclar las preguntas
    function shuffleQuestions() {
        $('ol').each(function() {
            var ol = $(this);
            var liArr = ol.children('li');
            liArr.sort(function() {
                return (Math.round(Math.random()) - 0.5);
            }).detach().appendTo(ol);
        });
    }

    // Funcin para mezclar las opciones dentro de cada pregunta
    function shuffleOptions() {
        $('ul.radio-list').each(function() {
            var ul = $(this);
            var liArr = ul.children('li');
            liArr.sort(function() {
                return (Math.round(Math.random()) - 0.5);
            }).detach().appendTo(ul);
        });
    }

    // Llamar a las funciones para mezclar las preguntas y las opciones al cargar la pgina
    shuffleQuestions();
    shuffleOptions();
});</script>
</div>
</body>
</html>