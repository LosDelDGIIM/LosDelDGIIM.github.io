<!DOCTYPE html>
<html lang="es">
<head>
    <title>LosDelDGIIM | Test</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet">
    <meta charset="UTF-8">

    <link rel="icon" href="../../../../assets/Icon.png">

    
    
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
            integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
            crossorigin="anonymous"></script>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
          
</head>
<body>

<div class="container">
    <div class="form-row">
        <div class="container">
            <h1>Métodos Numéricos II. Test Primer Parcial.</h1>
<p><strong>Autor:</strong> Lucas Hidalgo Herrera <br>
<strong>Descripción:</strong> Test de los temas 1 y primera parte del 2.</p>
<hr>
<ol>
<li>
<p>Sea \(g\) una función real continua en un intervalo \([a, b]\).</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \( g \) toma valores en \([ \frac{a+b}{2}, b ]\), entonces tiene al menos un punto fijo en \([a, b]\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> La ecuación \(x = g(x)\) tiene una única raíz en \([a, b]\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \(g\) toma valores en \([a, b]\) y es contráctil, entonces tiene un único punto fijo en \([a, b]\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si \(g\) toma valores en \([a, b]\) y es derivable con derivada menor que 1 en todo punto, entonces el correspondiente método de iteración funcional es convergente partiendo de un punto diferente de \(s\) pero suficientemente cercano.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \( g \) toma valores en \([a, b]\), entonces tiene al menos un punto fijo en \([a, b]\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> La ecuación \( x = g(x) \) tiene al menos una raíz en \([a, b]\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si \( g \) toma valores en \([a, b]\) y es derivable, entonces el correspondiente método de iteración funcional es convergente partiendo de un punto diferente de \( s \) pero suficientemente próximo a \( s \).</label></li>
</ul>
</li>
<li>
<p>Sea \(f\) una función continua en \([a, b]\) con valores en \(\mathbb{R}\), tal que \(f(a)f(b) &lt; 0\).</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si \(f\) es derivable en \([a, b]\) la ecuación \(f(x) = 0\) tiene una sola raíz en \([a, b]\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si la derivada de \(f\) existe y en todo el intervalo abierto es negativa, entonces hay solo una raíz de \(f(x) = 0\) en el intervalo.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Tanto el método de bisección como el de Regula Falsi son convergentes, pero pueden converger a dos raíces diferentes de la ecuación \(f(x) = 0\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La ecuación \(f(x) = 0\) tiene al menos una raíz en el intervalo abierto \([a, b]\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si la derivada de \(f\) existe y en todo el intervalo abierto es negativa, entonces el método de NR converge a la única raíz de \(f(x) = 0\), partiendo del centro del intervalo.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El método de la secante es aplicable pero no tiene garantía de convergencia a ninguna de las raíces de la ecuación \(f(x) = 0\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \(f\) es suficientemente derivable y en todo el intervalo abierto su primera derivada es negativa, entonces el método de NR converge a la única raíz de \(f(x) = 0\), partiendo de cualquier punto de algún subintervalo que contenga a la raíz.</label></li>
</ul>
</li>
<li>
<p>Iteraciones</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> El método de Newton-Raphson requiere una semilla.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El método de la Secante obtiene cada aproximación a partir de los dos anteriores.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El método de Newton-Raphson tiene siempre convergencia local cuadrática.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El método de la secante requiere una semilla.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El método de iteración funcional requiere una semilla.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El método de Bisección requiere una semilla.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si la raíz es simple, entonces el método de Newton-Raphson tiene convergencia local al menos cuadrática.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Cuando las aproximaciones están muy próximas a la solución, el método de la Secante puede incurrir en división por cero al computar.</label></li>
</ul>
</li>
<li>
<p>Si la función \(f(x)\) no es derivable, pero es continua y \(f(a)f(b) &lt; 0\), entonces puedo aplicar los métodos de:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Sólo los métodos de iteración funcional.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Newton-Raphson y secante.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Bisección y Newton-Raphson.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Bisección, Secante y Regula Falsi.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Todos los métodos estudiados.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Bisección.</label></li>
</ul>
</li>
<li>
<p>Tiene orden de convergencia local al menos cuadrático...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> La iteración funcional cuando \(|g'(s)| &lt; 1\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El método de Newton-Raphson cuando la raíz es simple.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El método de la secante cuando la raíz es simple.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La iteración funcional cuando \(g \in \mathcal{C}^2\) y \(|g'(s)| = 0\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El método de bisección.</label></li>
</ul>
</li>
<li>
<p>Un algoritmo eficiente y estable para la evaluación de polinomios es:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> El producto escalar del vector de coeficientes por el vector de potencias de la variable.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El de Sturm.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El de Newton-Raphson.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El de Bisección seguido del de Newton-Raphson.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El de Horner.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El de Bisección.</label></li>
</ul>
</li>
<li>
<p>Sea \(f\) una función real definida en un intervalo cerrado \([a, b]\). Entonces:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> No hay garantía de convergencia del método de la secante a una raíz de la ecuación \(f(x) = 0\), partiendo de las semillas \(a\) y \(b\) como valores iniciales.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si \(f(a)f(b) &lt; 0\) entonces hay al menos un punto \(s\) comprendido entre \(a\) y \(b\) en el cual la función vale cero.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Para que el método de la secante sea aplicable se necesita que \(f(a)f(b) &gt; 0\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> La ecuación \(f(x) = 0\) tiene un número impar de raíces simples en \([a, b]\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si la ecuación \(f(x) = 0\) tiene una única raíz en \([a, b]\) siempre puede aplicarse el método de bisección para aproximarla con un error menor que 0.05.</label></li>
</ul>
</li>
<li>
<p>Si tiene que resolver un sistema no lineal de dos ecuaciones, \(F(X) = 0\).</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Aplicaría Newton-Raphson a cada una de las dos ecuaciones.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Necesitaría dos semillas, una para cada componente.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Aplicaría primero el método de Bisección que es un método lento pero robusto.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si existe la matriz Jacobiana de orden \(2 \times 2\), asociada a \(F\), con determinante no nulo, aplicaría Newton-Raphson para sistemas.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Lo más recomendable sería intentar resolverlo por el método de Newton-Raphson para sistemas, pero también se puede intentar escribir el sistema como \(X = G(X)\), que sea equivalente, y analizar si la correspondiente iteración funcional va a ser convergente.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Necesitaría dos semillas si se quiere resolver por el método de la secante.</label></li>
</ul>
</li>
<li>
<p>Sucesión de Sturm</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Permite saber si una ecuación polinómica tiene raíces múltiples.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> En un cero de la primera función la derivada de dicha función tiene el mismo signo que la siguiente función.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si la sucesión consta de cuatro funciones y la tercera se anula en un punto \(r\), la segunda no se anula y su signo es el contrario que el de la cuarta en \(r\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Para obtener la tercera función de una sucesión de Sturm correspondiente a un polinomio cuyos ceros reales sean simples debemos dividir el polinomio entre su derivada y quedarnos con el resto cambiado de signo.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> A partir de un polinomio cualquiera puede obtenerse una sucesión de Sturm que tiene a dicha función como la primera función de dicha sucesión.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Permite separar raíces reales de una ecuación polinómica en intervalos disjuntos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Para construir una sucesión de Sturm a partir de un polinomio, se pone en primer lugar ese polinomio, en segundo lugar su derivada, y así sucesivamente hasta que se obtenga una función constante.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> En un cero de la primera función la derivada de esa función es no nula.</label></li>
</ul>
</li>
<li>
<p>Si \(s\) es una raíz de multiplicidad \(m &gt; 1\) del polinomio \(p\), entonces también es raíz de \(p'\) pero con multiplicidad:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(m\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> 1</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> 2</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> No se puede saber, depende de otros factores.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(m - 2\)</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(m - 1\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> No es raíz de \(p'\).</label></li>
</ul>
</li>
<li>
<p>Para poder aplicar el método de la secante, la función \(f(x)\) ha de ser necesariamente:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Continua.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Derivable \(1 + \frac{\sqrt{5}}{2}\) veces.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Creciente.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Derivable dos veces.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Derivable una vez.</label></li>
</ul>
</li>
<li>
<p>La sucesión \(x_n\) converge a \(s\) linealmente con constante asintótica del error \(L = 1/\sqrt[5]{100}\) entonces, a largo plazo...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> se ganan 2 dígitos de precisión cada 5 términos</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> se ganan 100 dígitos de precisión cada 5 términos</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> no puede ser convergente</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> se ganan 5 dígitos de precisión cada 100 términos</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> se ganan 5 dígitos de precisión cada 2 términos</label></li>
</ul>
</li>
<li>
<p>Sucesión de Sturm</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Todas las funciones son continuas, al menos, y la primera debe ser como mínimo derivable.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Basta con que las funciones que la componen sean continuas en el intervalo común de definición.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Sirve exclusivamente para saber cuántas raíces reales tiene una ecuación polinómica.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La última función no cambia de signo en el intervalo que estamos considerando.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Todas las funciones que la componen deben ser de clase uno o superior.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Permite saber cuántas raíces complejas tiene una ecuación polinómica cuyas raíces reales son simples.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> La sucesión de Sturm nos permite saber si un método iterativo converge o diverge.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La primera de las funciones debe ser derivable en todo el intervalo que estamos considerando.</label></li>
</ul>
</li>
<li>
<p>Toda función de iteración \(g(x)\) definida en \([0, 10]\)...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> con valores en el intervalo \([5, 7]\) tiene al menos un punto fijo.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> continua y con valores en el intervalo \([5, 7]\) tiene un único punto fijo.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> con valores en el intervalo \([5, 7]\) tiene un único punto fijo.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> con valores en el intervalo \([5, 7]\) y derivada en valor absoluto menor que 1 en \([0, 10]\) ha de tener un único punto fijo.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> continua y con valores en el intervalo \([5, 7]\) tiene al menos un punto fijo.</label></li>
</ul>
</li>
<li>
<p>Sea \(f\) de clase 1, \(s \in \mathbb{R}\) es una raíz simple de \(f\) si y solo si</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(f(s) = 0 \ y \ f'(s) \neq 0\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(f(s) \neq 0 \ y \ f'(s) = 0\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(f(s) \cdot f'(s) = 0\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El método de Newton-Raphson converge localmente a \(s\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(f(s) = 0 \ y \ f'(s) = 0\)</label></li>
</ul>
</li>
<li>
<p>La sucesión \(x_n\) converge a \(s\) linealmente con constante asintótica del error \(L = 1/\sqrt{100000}\). Entonces, a largo plazo...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> se ganan 5 dígitos de precisión cada 2 términos</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> se ganan al menos 10 dígitos de precisión cada 5 términos</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> se ganan 2 dígitos de precisión cada 5 términos</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> se ganan 2 dígitos de precisión cada 100000 términos</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> no converge</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> se ganan 1 dígito de precisión cada 5 términos</label></li>
</ul>
</li>
<li>
<p>Sea la ecuación \(x = g(x)\). Entonces, si \(g\) aplica el intervalo \([a, b]\) en \([a, b]\):</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si \(g\) es derivable y su derivada es negativa pero mayor que \(-\frac{1}{2}\), entonces el método de iteración funcional asociado genera una sucesión de aproximaciones decreciente hacia la raíz de la ecuación \(x = g(x)\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si \(g\) es derivable y su derivada está acotada en valor absoluto por \(\frac{1}{2}\) en todo el intervalo, entonces el método de iteración funcional asociado tiene convergencia al menos cuadrática.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \(g\) es de clase 2 y en un punto fijo \(s\) verifica \(g'(s) = 0\), entonces partiendo de un valor suficientemente próximo a \(s\) el método de iteración funcional converge con orden de convergencia al menos cuadrático.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \(g\) es derivable y su derivada está acotada en valor absoluto por \(\frac{1}{2}\) en todo el intervalo, entonces el método de iteración funcional asociado comete tras \(n\) iteraciones un error menor que \(\frac{b-a}{2^n}\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El método de iteración funcional asociado coincide con el de NR cuando la función \(g\) es derivable.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El método de iteración funcional asociado es localmente convergente a toda raíz \(s\) de dicha ecuación que verifique \(-1 &lt; g'(s) &lt; 1\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \(g\) es derivable y su derivada es positiva pero menor que \(\frac{1}{2}\), entonces el método de iteración funcional genera una sucesión de aproximaciones monótona hacia la raíz de la ecuación \(x = g(x)\)</label></li>
</ul>
</li>
<li>
<p>Ecuaciones polinómicas</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> La ecuación \(7x^7 - 12x^5 - 3x^3 + 1 = 0\) no tiene raíces positivas.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La ecuación \(6x^7 - 2x^5 - 3x^3 + 1 = 0\) tiene sus raíces reales en \([-1.5, 1.5]\)</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(7x^7 + 12x^5 + 3x^3 + 1 = 0\) no tiene raíces positivas.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(x^7 - 21x^6 + 3x^3 - 12 = 0\) no puede tener sus raíces reales fuera del intervalo \([-13, 13]\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> La ecuación \(2x^7 - 12x^5 - 3x^3 + 1 = 0\) no puede tener raíces con módulo mayor que 1.5</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La ecuación \(7x^7 + 2x^5 - 3x^3 + 1 = 0\) no puede tener raíces con módulo mayor que 1.5.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(x^7 - 12x^5 + 3x^3 - 1 = 0\) tiene sus raíces reales en \([-13, 13]\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(7x^7 + 12x^5 + 3x^3 + 1 = 0\) no tiene raíces reales.</label></li>
</ul>
</li>
<li>
<p>El método de bisección</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> tiene orden de convergencia local al menos cuadrático</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> se puede extender a sistemas de ecuaciones no lineales</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> exige las mismas condiciones que el teorema de Bolzano</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> requiere una semilla</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> es un método de iteración funcional</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> tiene orden de convergencia lineal</label></li>
</ul>
</li>
<li>
<p>Marque las afirmaciones que sean ciertas sobre el método de Bisección</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Reduce el error a la mitad en cada iteración.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La sucesión de cotas de errores en el método de bisección es monótona decreciente.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> La sucesión de errores en el método de bisección es monótona decreciente.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Permite calcular el número necesario de iteraciones para alcanzar una precisión dada, antes de realizarlas.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Tiene velocidad cuadrática de convergencia.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Ninguna de las demás.</label></li>
</ul>
</li>
<li>
<p>Para poder aplicar el método de Newton-Raphson, la función \(f(x)\) tiene que ser</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Dos veces derivable</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Con que sea continua es suficiente</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Creciente</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Derivable</label></li>
</ul>
</li>
<li>
<p>La fórmula \(f'(0)\approx0\)</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Es exacta para todo polinomio que sea una función par.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Es una fórmula de tipo interpolatorio con un solo nodo, que puede ser el que se quiera.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Es una de las fórmulas más precisas para aproximar el valor de la derivada de una función en cero.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Es exacta para \(1,x, x^2, x^3, x^4\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Es exacta para las funciones: \(1, \cos(x)\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Es exacta para \(1,x^2,x^3,x^4\).</label></li>
</ul>
</li>
<li>
<p>Fórmulas de derivación numérica de tipo interpolatorio</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Una de las fórmulas de derivación numérica para aproximar \(f'(a)\) es \(\frac{f(a+h)-f(a-h)}{2h}\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Una de las fórmulas de derivación numérica para aproximar es \(\frac{f(a)-f(a+h)}{-h}\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Las fórmulas de derivación numérica más habituales tienen un nodo, dos nodos o tres nodos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" />Las fórmulas de derivación numérica son imprescindibles para derivar funciones de las que no se conoce una primitiva expresada en términos elementales.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Las fórmulas de derivación numérica pueden ser simples o compuestas</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Una de las fórmulas de derivación numérica para aproximar más recomendable es \(f(a+h)-f(a-h)/(2h)\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Al aplicar una fórmula de derivación numérica, basada en los valores de la función en los puntos \(a\) y \(a+h\), el valor de \(h\) no puede ser nulo</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Al aplicar una fórmula de derivación numérica, basada en los valores de la función en los puntos \(a\) y \(a+h\), el valor de \(h\) no puede ser negativo</label></li>
</ul>
</li>
<li>
<p>Una fórmula de tipo interpolatorio clásico para aproximar la derivada \(k\)-ésima de en un punto ...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> que use \(n\) nodos, puede tener como máximo orden de exactitud \(k+n-1\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> no tiene interés si el número de nodos es menor o igual que \(k\) .</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> que use \(n\) nodos, puede tener como máximo orden de exactitud \(n+k\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> que use \(n\) nodos, puede tener como máximo orden de exactitud \(k\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> debe tener al menos \(k+1\) nodos, para que tenga algún interés.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> que use \(n\) nodos, puede tener como máximo orden de exactitud \(n-1\).</label></li>
</ul>
</li>
<li>
<p>Toda fórmula de derivación numérica de tipo interpolatorio clásico para aproximar una derivada \(k\)-ésima en \(a\) ...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> tiene al menos un coeficiente positivo y al menos otro negativo.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> tiene unos coeficientes que pueden obtenerse resolviendo un sistema lineal del mismo orden que el número de nodos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> tiene unos coeficientes que son idénticos.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> tiene unos coeficientes que son las derivadas \(k\)-ésimas, en \(k\), de los polinomios de Lagrange correspondientes a los nodos.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> tiene unos coeficientes que suman cero.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> tiene unos coeficientes que son simétricos.</label></li>
</ul>
</li>
<li>
<p>Fórmula:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si la función \(f\) es suficientemente regular, siempre es posiblle aproximar el valor \(f'(a)\) con un error \(|R(f)|&lt;0.1\), tomando un valor de \(h\) suficientemente pequeño en una fórmula de tipo interpolatorio clásico que use un nodo.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Para aplicar una fórmula de derivación numérica para aproximar \(f'(a)\) se necesita poder obtener los valores \(f\) de en puntos cercanos al \(a\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Una fórmula de derivación numérica para aproximar \(f'a\) con un error \(|R(f)|&lt;0.1\),que sea convergente, salvo errores de computación, tiene que ser de tipo interpolatorio.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si la función \(f\) es suficientemente regular, siempre es posible aproximar el valor \(f'(a)\) con un error \(|R(f)|&lt;0.1\), tomando un valor de \(h\)suficientemente pequeño en una fórmula de tipo interpolatorio clásico que use dos nodos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> No existe ninguna fórmula de derivación numérica para aproximar \(f'(a)\) con un error \(|R(f)|&lt;0.1\) que tenga más de cinco nodos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Para aplicar una fórmula de derivación numérica para aproximar \(f'(a)\) se necesita conocer la expresión de en un entorno del punto \(a\).</label></li>
</ul>
</li>
<li>
<p>La fórmula \(f'(3) \approx f(-1) + f(0) + f(2)\)</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Tiene por término de error \(R(f) = f'(3) - f(-1) - f(0) - f(2)\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Es de tipo interpolatorio clásico.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Es exacta de grado 1.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Es exacta de grado 0.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> No es de tipo interpolatorio clásico.</label></li>
</ul>
</li>
<li>
<p>Grado de exactitud</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Dos fórmulas de derivación numérica, de tipo interpolatorio clásico, para aproximar \(f^{''}(a)\), con los mismos nodos, pueden tener diferentes pesos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El grado de exactitud de una fórmula de tipo interpolatorio clásico depende exclusivamente del número de nodos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El grado de exactitud de una fórmula de tipo interpolatorio clásico no depende de sus nodos sino de los pesos.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Dos fórmulas de derivación numérica, para aproximar \(f^{''}(a)\), con igual número de nodos, pueden tener diferentes pesos.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El grado de exactitud de una fórmula de tipo interpolatorio clásico depende exclusivamente de quiénes sean sus nodos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Dos fórmulas de derivación numérica, para aproximar \(f^{''}(a)\), con igual número de nodos, tienen el mismo grado de exactitud.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Dos fórmulas de derivación numérica, para aproximar \(f^{''}(a)\), con diferente número de nodos, pueden tener el mismo grado de exactitud.</label></li>
</ul>
</li>
<li>
<p>Una fórmula de derivación numérica de tipo interpolatorio clásico para aproximar \(f'(a)\)...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> con dos nodos, no puede ser exacta en \(\mathbb{P}_2\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> con dos nodos, no puede ser exacta en \(\mathbb{P}_1\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> con dos nodos, puede ser exacta en \(\mathbb{P}_3\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> con dos nodos, puede obtenerse imponiendo exactitud para las funciones \({1,x}\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> con \(n\) nodos, es siempre exacta en \(\mathbb{P}_n\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> con \(n\) nodos, podría ser exacta en \(\mathbb{P}_n\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> con dos nodos, podría ser exacta en \(\mathbb{P}_2\).</label></li>
</ul>
</li>
<li>
<p>El funcional lineal \(f'(a)\) puede aproximarse por la fórmula progresiva \(P(h) = \frac{f(a+h)-f(a)}{h}\) de tal forma que si \(f\) es suficientemente regular, desarrollando por Taylor se tiene \(f'(a)=P(h)-\frac{h}{2}f^{''}(a)-\frac{h^2}{6}f^{'''}(a)-...=P(h)+c_1h+c_2h^2+...\). Si ahora se escribe para \(\frac{h}{2}\) resulta \(f'(a)=P(\frac{h}{2})+c_1\frac{h}{2}+c_2\frac{h^2}{4}+...\)</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> No existe una combinación lineal de \(P(h)\) y \(P(\frac{h}{2})\)que permita obtener una fórmula para aproximar \(f'(a)\) con mayor orden de exactitud.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> No es posible establecer una combinación de \(P(h)\) y \(P(\frac{h}{2})\) que aumente la exactitud en 2 unidades.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Toda combinación lineal de \(P(h)\) y \(P(\frac{h}{2})\) mantiene el mismo orden de exactitud.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La combinación \(2P(\frac{h}{2})-P(h)\) aumenta en una unidad el orden de exactitud.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La combinación \(\frac{1}{3}(2P(\frac{h}{2})+P(h))\) no aumenta en una unidad el orden de exactitud,pero es convergente a \(f'(a)\) cuando \(h\) tiende a \(0\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> La combinación \(\frac{1}{3}(2P(\frac{h}{2})+P(h))\) aumenta en una unidad el orden de exactitud y es convergente a \(f'(a)\) cuando \(h\) tiende a \(0\).</label></li>
</ul>
</li>
<li>
<p>Una fórmula de derivación numérica de tipo interpolatorio clásico (en los polinomios), para aproximar \(f'(a)\), que tenga dos nodos...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> no puede ser exacta en \(\mathbb{P}_2\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> es exacta en \(\mathbb{P}_1\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> puede obtenerse imponiendo exactitud para las funciones \(x,x^2\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> puede alcanzar un grado máximo de exactitud 3.</label></li>
</ul>
</li>
<li>
<p>Para obtener tres fórmulas para aproximar respectivamente \(f'(a)\), \(f^{''}(a)\) y \(f^{'''}(a)\) se han elegido cinco abscisas diferentes, se ha calculado el polinomio \(p(x)\) de grado cuatro que interpola en ellas los valores de la función \(f\), y se ha derivando sucesivamente \(p(x)\) para obtenerlas.</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Las tres fórmulas de derivación numérica obtenidas son exactas para las funciones \(x^3\) y \(x^4\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si las abscisas de interpolación están igualmente espaciadas con un paso \(h\) y uno de los cinco nodos es \(a\), la fórmula que aproxima \(f'(a)\) tendrá \(h\) en el denominador, la que aproxima \(f^{''}(a)\) tendrá \(h^2\) y la tercera tendrá \(h^3\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Las tres fórmulas de derivación numérica obtenidas contienen el mismo número de nodos con pesos no nulos.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> No se pueden obtener tres fórmulas de derivación numérica diferentes partiendo de un mismo polinomio de interpolación.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Las tres fórmulas de derivación numérica obtenidas tienen unos pesos que suma cero.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Las tres fórmulas de derivación numérica obtenidas tienen el mismo orden de exactitud.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El procedimiento más simple es obtener la fórmula para \(f'(a)\) a partir de \(p'(a)\), y después derivar \(f'(a)\) un par de veces para obtener \(f^{''}(a)\) y \(f^{'''}(a)\).</label></li>
</ul>
</li>
<li>
<p>El funcional lineal \(f'(a)\) puede aproximarse por la fórmula \(P(h) = \frac{f(a+h)-f(a-h)}{2h}\) de tal forma que si \(f\) es suficientemente regular, desarrollando por Taylor se tiene \(f'(a)=P(h)+c_2h^2+c_4h^4+...\), que escrita para \(\frac{h}{2}\) es \(f'(a)=P(\frac{h}{2})+c_2\frac{h^2}{4}+c_4\frac{h^4}{16}+...\). Este proceso es el de extrapolación de Richardson aplicado a una fórmula de derivación numérica. Entonces:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(\frac{1}{3}(4P(\frac{h}{2})+P(h))\) aumenta la exactitud con respecto a \(P(h)\) en 2 unidades.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(P(h)\) es la aproximación \(f'(a)\) con la fórmula centrada.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(\frac{1}{3}(4P(\frac{h}{2})-P(h))\) aumenta la exactitud con respecto a \(P(h)\) al menos en una unidad.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> No es posible establecer una combinación de \(P(h)\) y \(P(\frac{h}{2})\) que aumente la exactitud en 2 unidades.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(\frac{1}{3}(2P(\frac{h}{2})+P(h))\) aumenta la exactitud con respecto a \(P(h)\) en al menos una unidad.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(2P(\frac{h}{2})-P(h)\) aumenta la exactitud con respecto a \(P(h)\) en una unidad.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(P(h)\) tiene orden de exactitud 1.</label></li>
</ul>
</li>
<li>
<p>Si \(g\) es derivable y aplica \([a,b]\) en \([a,b]\). Entonces:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si existe la derivada segunda de \(g\) y se verifica que \(g(s)=s\) y \(g'(s)=g^{''}(s)=0\), la convergencia local del método de iteración funcional es al menos cúbica.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \(g(s)=s\) y \(g'(s)=0\), existe un entorno de \(s\) en cual la convergencia a \(s\) del método de iteración funcional asociado a \(g\) es al menos cuadrática. </label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si existe la derivada segunda de \(g\) y se verifica que \(g^{''}(s)=0\), la convergencia del método de iteración funcional es al menos cúbica.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si \(g(s)=s\) y \(g'(s)=0\), existe un entorno de \(s\) en cual la convergencia a \(s\) del método de iteración funcional asociado a es más rápida que si aplicamos el método de NR a \(f(x)=x-g(x)\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si existe la derivada segunda de \(g\) y se verifica que \(g(s)=s\) y \(g'(s)=g^{''}(s)=0\), la convergencia local del método de iteración funcional es cúbica.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si existe la derivada segunda de \(g\) y se verifica que \(g(s)=s\) y \(g'(s)=g^{''}(s)=0\), la convergencia local del método de iteración funcional es al menos cuadrática.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Si \(g(s)=s\) y \(g'(s)=0\), existe un entorno de \(s\) en cual la convergencia a \(s\) del método de iteración funcional asociado a \(g\) es exactamente cuadrática.</label></li>
</ul>
</li>
<li>
<p>Error:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> El error de una fórmula de derivación numérica de tipo interpolatorio, para aproximar \(f'(a)\), es la derivada del error de interpolación correspondiente, evaluada en \(a\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El error de una fórmula de derivación numérica de tipo interpolatorio, para aproximar \(f'(a)\), puede obtenerse derivando \(f[x_0,x_1,...,x_n,x]\) y evaluando en \(a\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La derivada de \(f[x_0,x_1,...,x_n,x]\) es \(f[x_0,x_1,...,x_n,x,x]\) y la derivada segunda es \(2f[x_0,x_1,...,x_n,x,x,x]\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> La derivada de \(f[x_0,x_1,...,x_n,x]\) es \(f[x_0,x_1,...,x_n,x,x]\) y la derivada segunda es \(f[x_0,x_1,...,x_n,x,x,x]\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El error de una fórmula de derivación numérica de tipo interpolatorio, para aproximar \(f^{''}(a)\), es la derivada segunda del error de interpolación correspondiente, evaluada en \(a\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El error de una fórmula de derivación numérica de tipo interpolatorio clásico, para aproximar \(f'(a)\), puede obtenerse desarrollando por Taylor el valor de en los diferentes nodos en torno al nodo \(a \).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El error de una fórmula de derivación numérica de tipo interpolatorio clásico, para aproximar \(f'(a)\), puede obtenerse derivando \(f[x_0,x_1,...,x_n,x] (x-x_0) ... (x-x_n) \) y evaluando en \(a\).</label></li>
</ul>
</li>
<li>
<p>Las fórmulas de tipo interpolatorio...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> son la de Lagrange y la de Newton.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> algunas de ellas sirven para aproximar la derivada de una función en un punto.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> sólo son exactas para polinomios.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> algunas de ellas sirven para aproximar la ntegral definida de una función en un intervalo.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> carecen de término de error.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> son exactas en un cierto espacio de funciones.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> sirven exclusivamente para aproximar la derivada de una función en un punto o su integral definida en un intervalo. </label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> son fórmulas de interpolacíón.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> sirven para aproximar un funcional lineal, como cierta derivada de una función en un punto, o el valor de la integral definida de una función en un intervalo.</label></li>
</ul>
</li>
<li>
<p>Si se calcula el polinomio \(p(x)\) de grado \(2\) que interpola a una función \(f\) en \(a\), \(a+h\) y \(a+2h\)...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="0" data-content="1" /> A partir de \(p(x)\) se puede obtener una fórmula para aproximar \(f'(a)\) y otra para aproximar \(f^{''}(a)\) y ambas son exactas para \(1,x,x^2\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> A partir de \(p(x)\) se puede obtener una fórmula para aproximar \(f'(a)\) solamente cuando los datos conocidos de \(f\) son tres puntos igualmente espaciados, y siendo \(a\) el menor de los tres.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> \(p'(a)\) es una aproximación de \(f'(a)\), exacta para \(1,x,x^2\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> \(p'(a)\) es una aproximación de \(f'(a)\), exacta para \(a,a+h,a+2h\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> A partir de \(p(x)\) se puede obtener una fórmula para aproximar \(f'(1)\) a partir de \(f(1),f(0.9),f(0.8)\).</label></li>
</ul>
</li>
<li>
<p>Una función periódica de periodo \(2\pi\), se aproxima interpolando con funciones de espacios trigonométricas, es decir, generados por: \(1,\sin(x),\cos(x),\sin(2x),\cos(2x),\sin(3x),...\) Se quiere aprovechar esos interpolantes para obtener una fórmula de derivación numérica, efectuando la derivada correspondiente del interpolante. En tal caso:</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> La fórmula correspondiente a los nodos: \(0,\frac{\pi}{2},\pi\), sería exacta para \(1,x,x^2\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Sería una fórmula de tipo interpolatorio clásico.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El error de la fórmula se obtendría a partir de desarrollos en serie de Taylor.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Para obtener la fórmula que aproxime \(f'(\frac{\pi}{2})\) usando como nodos: \(0,\frac{\pi}{2},\pi\), se puede exigir exactitud en \(1,\sin(x),cos(x)\) y resolver el sistema correspondiente.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Para obtener la fórmula que aproxime \(f'(\frac{\pi}{2})\) usando como nodos: \(0,\frac{\pi}{2},\pi\), se puede calcular el interpolante trigonométrico con la fórmula de Newton, derivarlo y evaluarlo en \(\frac{\pi}{2}\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> No sería una fórmula de tipo interpolatorio.</label></li>
</ul>
</li>
<li>
<p>Funcionales lineales.</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> El funcional lineal \(L(f)=f'(a)2f^{''}(a)\) es lineal.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Las fórmulas de derivación numérica sirven para aproximar el valor de un funcionale lineal, tales como: \(L(f)=f'(a)\), \(L(f)=f^{''}(a)\), \(L(f)=f^{'''}(a)\), etc.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> Si \(a&gt;0\), el funcional \(L(f)=f(\sqrt{a})\) es lineal. </label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> Para funciones mayores que cero \(L(f)=\sqrt{(f(a))}\) es lineal.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El funcional \(L(f)=f'(a)+2f^{''}(a)+3\) es lineal.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El funcional \(L(f)=f'(a)+2f^{''}(a)\) es lineal.</label></li>
</ul>
</li>
<li>
<p>La fórmula \(\frac{1}{5}(3\frac{f(a+h)-f(a)}{h}+2\frac{f(a)-f(a-h)}{h})\) para aproximar \(f'(a)\)...</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> es exacta para: \(1,x,x^2\), porque usa tres nodos \(a-h,a,a+h\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> es una combinación de una fórmula progresiva y otra regresiva para aproximar \(f'(a)\).</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> puede tener un error de truncatura tan pequeño como se desee, si \(f\) es de clase \(2\).</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> no es de derivación numérica.</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> es de tipo interpolatorio clásico.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> no es una de las fórmula habituales usadas en la derivación numérica. </label></li>
</ul>
</li>
<li>
<p>Se desea aproximar \(f^{'''}(0)\) mediante una fórmula de tipo interpolatorio que use \(f(-1),f(0),f(1)\)</p>
<ul class="checklist">
<li><label><input type="checkbox" data-question="1" data-content="0" /> Es necesario calcular los pesos de la fórmula y despues aplicarla.</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> La fórmula será \(f^{'''}(0)\approx0\)</label></li>
<li><label><input type="checkbox" data-question="1" data-content="0" /> El término del error será \(R(f)=\frac{f^{'''}(0)}{3!}\)</label></li>
<li><label><input type="checkbox" data-question="0" data-content="1" /> El término del error será \(R(f)=f^{'''}(0)\)</label></li>
</ul>
</li>
</ol>
        </div>
    </div>
    <div id="tg-msg" class="alert" role="alert" style="display: none">
        <span id="tg-correct-questions"></span> Correct! <br /><b>Rating: <span id="tg-score"></span>%</b>
    </div>
    <div class="row">
        <button id="show-answers" class="btn btn-link">Mostrar respuestas correctas</button>
    </div>
    <div class="row">
        <button id="reset-questions" class="btn btn-link">Reiniciar todo</button>
    </div>
    <script type="text/javascript">$(function () {
    $('ul.radio-list, ul.checklist, ul.textbox').each(function (i, el) {
        var questionClass = $(this).attr('class');
        $(this).parent().addClass('question-row').addClass(questionClass);
        if (questionClass == 'radio-list') {
            $(this).find('input[type="radio"]').attr('name', 'radio-question-' + i);
        }
    });

    function checkQuestion(question) {
        var self = question;

        // Single Question.
        if (self.hasClass('radio-list')) {
            if (self.find('input[type="radio"][data-content="1"]:checked').length == 1) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="radio"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
            }
        }
        // Textbox Question.
        if (self.hasClass('textbox')) {
            var textbox = self.find('input[type="text"]');
            var correct_text = String(textbox.data("content")).trim().split("").reverse().join("");
            if (String(textbox.val()).trim().toLowerCase() == correct_text.toLowerCase()) {
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="text"]').attr('disabled', true);
            } else {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.addClass('text-danger');
                textbox.parent().find("i.text-correct").html(correct_text);
            }
        }
        // Multiple selection Questions.
        if (self.hasClass('checklist')) {
            var total_corrects = self.find('input[type="checkbox"][data-content="1"]').length;
            var total_incorrects = self.find('input[type="checkbox"][data-content="0"]').length;
            var correct_selected = self.find('input[type="checkbox"][data-content="1"]:checked').length;
            var incorrect_selected = self.find('input[type="checkbox"][data-content="0"]:checked').length;
            var qc = +((correct_selected / total_corrects) - (incorrect_selected / total_incorrects)).toFixed(2);
            if (qc < 0) {
                qc = 0;
            }
            if (qc == 0) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-warning');
                self.addClass('text-danger');
            } else if (qc > 0 && qc < 1) {
                self.removeClass('text-success'); // Eliminar la marca de respuesta correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-warning');
            } else {
                self.removeClass('text-warning'); // Eliminar la marca de respuesta parcialmente correcta
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.addClass('text-success');
                self.removeClass('text-danger'); // Eliminar la marca de respuesta incorrecta
                self.find('input[type="checkbox"]').attr('disabled', true);
            }
        }
    }

    $('li.question-row input').on('change', function () {
        var question = $(this).closest('li.question-row');
        checkQuestion(question);
    });

    $('#reset-questions').on('click', function () {
        $('li.question-row').removeClass('text-success').removeClass('text-danger').removeClass('text-warning');
        $('i.text-correct').html('');
        $('li.question-row input').prop('checked', false);
        $('li.question-row input[type="text"]').val('');
        $('li.question-row input').attr('disabled', false);
    });

    // Funcin para mostrar todas las respuestas correctas
    $('#show-answers').on('click', function () {
        $('li.question-row').each(function () {
            var question = $(this);

            // Mostrar respuestas correctas para preguntas de tipo radio
            if (question.hasClass('radio-list')) {
                question.find('input[type="radio"][data-content="1"]').prop('checked', true);
                question.addClass('text-success');
                question.find('input[type="radio"]').attr('disabled', true); // Bloquear inputs
            }

            // Mostrar respuestas correctas para preguntas de tipo checkbox
            if (question.hasClass('checklist')) {
                question.find('input[type="checkbox"][data-content="1"]').prop('checked', true);
                question.addClass('text-success');
                question.find('input[type="checkbox"]').attr('disabled', true); // Bloquear inputs
            }

            // Mostrar respuestas correctas para preguntas de tipo textbox
            if (question.hasClass('textbox')) {
                var textbox = question.find('input[type="text"]');
                var correct_text = String(textbox.data("content")).trim();
                textbox.val(correct_text);
                question.addClass('text-success');
                textbox.attr('disabled', true); // Bloquear inputs
            }
        });
    });

    
    // Funcin para mezclar las preguntas
    function shuffleQuestions() {
        $('ol').each(function() {
            var ol = $(this);
            var liArr = ol.children('li');
            liArr.sort(function() {
                return (Math.round(Math.random()) - 0.5);
            }).detach().appendTo(ol);
        });
    }

    // Funcin para mezclar las opciones dentro de cada pregunta
    function shuffleOptions() {
        $('ul.radio-list').each(function() {
            var ul = $(this);
            var liArr = ul.children('li');
            liArr.sort(function() {
                return (Math.round(Math.random()) - 0.5);
            }).detach().appendTo(ul);
        });
    }

    // Llamar a las funciones para mezclar las preguntas y las opciones al cargar la pgina
    //shuffleQuestions();
    //shuffleOptions();
});</script>
</div>
</body>
</html>