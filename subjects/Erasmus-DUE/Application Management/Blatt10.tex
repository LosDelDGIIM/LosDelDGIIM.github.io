\section{Fuzzing \& Z3}

\begin{ejercicio}
    Schauen Sie sich das \myhref{https://www.fuzzingbook.org}{Fuzzingbook} an. Sie können den benötigten Code mittels \verb|$ pip install fuzzingbook| installieren. Beschreiben Sie die folgenden Ansätze und erklären Sie die Unterschiede sowie die Vor- und Nachteile.
    \begin{enumerate}
        \item Random Fuzzing
        
        Random fuzzing involves generating random inputs to test a program. It is simple to implement and can be effective in finding bugs, but it is not very efficient in covering all possible input combinations.
        \item Mutation Fuzzing
        
        Mutation fuzzing takes existing inputs and mutates them to create new test cases. This approach can be more effective than random fuzzing, as it can explore the input space more systematically. However, it may still miss certain edge cases if the initial inputs are not diverse enough.
        \item Coverage-guided Fuzzing
        
        Coverage-guided fuzzing uses feedback from the program's execution to guide the generation of new inputs. It aims to maximize code coverage, which can help in finding more bugs. However, it can be more complex to implement and may require more computational resources.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}~
    \begin{enumerate}
        \item Schauen Sie sich an, welche SMT-Solver es gibt.
        
        The most popular SMT solvers include Z3, CVC4, and Yices. These solvers are widely used in various applications such as software verification, constraint solving, and formal methods.
        \item Nennen Sie einige Anwendungsgebiete, in denen SMT-Solver eingesetzt werden können.
        
        SMT solvers can be used in various domains, including software verification, hardware verification, automated theorem proving, and constraint solving. They are particularly useful in verifying the correctness of software and hardware designs, as well as in solving complex mathematical problems.
        \item Welche Herausforderungen können bei der Anwendung von SMT-Solvern auftreten und wie können sie bewältigt werden?
        
        Some challenges in using SMT solvers include scalability issues, handling of complex constraints, and the need for efficient encoding of problems. These challenges can be addressed by optimizing the encoding of problems, using heuristics to guide the search process, and leveraging parallelism to improve performance.
        \item Wie können SMT-Solver zur Sicherheitsanalyse von Softwareanwendungen beitragen?
        
        SMT solvers can be used in security analysis to identify vulnerabilities in software applications. They can help in finding input combinations that lead to security breaches, such as buffer overflows or injection attacks. By encoding the program's behavior and constraints, SMT solvers can systematically explore the input space to uncover potential security issues.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}~
    \begin{enumerate}
        \item Warum sind AddressSanitizer (ASan) nicht für den Produktivbetrieb geeignet?
        
        AddressSanitizer (ASan) is not suitable for production use because it introduces significant overhead in terms of performance and memory usage. ASan works by instrumenting the code to detect memory errors, which can slow down the execution of the program and increase its memory footprint. This can be unacceptable in a production environment where performance is critical.
        \item Was sind Redzones?
        
        Redzones are special areas of memory that are placed around allocated memory blocks to detect buffer overflows and underflows. If a program writes outside the bounds of an allocated block, it will overwrite the redzone, which can be detected by ASan to identify memory errors.
        \item Warum wird Shadow Memory benötigt?
        
        Shadow memory is used by ASan to keep track of the state of each byte of memory. For each 8 bytes of application memory, ASan uses 1 byte of shadow memory to store metadata about the state of that memory (e.g., whether it is allocated, freed, or part of a redzone). This allows ASan to efficiently detect memory errors by checking the shadow memory before accessing the application memory.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}\label{ex:z3}
    Schauen Sie sich das folgende Python-Programm an (Abbildung~\ref{lst:z3-example}).
    \begin{listing}
        \begin{minted}{python}
def func(a, b):
    x = 0
    y = 0
    if a > 0:
        x = 1
    if b == 0:
        y = 2
    assert x + y != 3
        \end{minted}
        \caption{Beispielcode für Übung~\ref{ex:z3}}
        \label{lst:z3-example}
    \end{listing}
    \begin{enumerate}
        \item Zeichnen Sie den Kontrollflussgraphen.
        
        The graphic can be seen in the Figure~\ref{fig:cfg}.
        \begin{figure}
            \centering
            \begin{tikzpicture}[
                    node distance=1.5cm,
                    block/.style={rectangle, draw, fill=blue!10, text width=3cm, align=center, rounded corners, minimum height=1cm},
                    pathConstraint/.style={rectangle, draw, fill=green!10, text width=3cm, align=center, rounded corners, minimum height=1cm},
                    decision/.style={diamond, draw, fill=yellow!10, aspect=2, text width=2cm, align=center, inner sep=0pt},
                    error/.style={rectangle, draw, fill=red!20, text width=3cm, align=center, rounded corners},
                    arrow/.style={thick, -{Stealth[scale=1.2]}}
                ]

                % Nodos
                \node (start) [block] {$x=0,\ y=0$};
                \node (if1) [decision, below= of start] {$a > 0$};
                \node (if1_T) [block, below left=1cm and 2.0cm of if1] {$x = 1,\ y=0$};
                \node (if1_F) [block, below right=1cm and 2.0cm of if1] {$x = 0,\ y=0$};
                \node (if2_1T) [decision, below= of if1_T] {$b == 0$};
                \node (if2_1F) [decision, below= of if1_F] {$b==0$};
                \node (if2_1T_T) [block, below left=1cm and 0cm of if2_1T] {$x=1,\ y=2$};
                \node (if2_1T_F) [block, below right=1cm and 0cm of if2_1T] {$x=1,\ y=0$};
                \node (if2_1F_T) [block, below left=1cm and 0cm of if2_1F] {$x=0,\ y=2$};
                \node (if2_1F_F) [block, below right=1cm and 0cm of if2_1F] {$x=0,\ y=0$};

                \node (if_2_1T_T_path) [pathConstraint, below of=if2_1T_T] {$a > 0 \land b == 0$};
                \node (if_2_1T_F_path) [pathConstraint, below of=if2_1T_F] {$a > 0 \land b \neq 0$};
                \node (if_2_1F_T_path) [pathConstraint, below of=if2_1F_T] {$a \leq 0 \land b == 0$};
                \node (if_2_1F_F_path) [pathConstraint, below of=if2_1F_F] {$a \leq 0 \land b \neq 0$};

                \node (fail) [error, below of= if_2_1T_T_path] {\textbf{AssertionError:} $x + y == 3$};

                % Flechas
                \draw [arrow] (start) -- (if1);
                \draw [arrow, color=green] (if1) -| node[anchor=east] {\color{green} T} (if1_T);
                \draw [arrow, color=red] (if1) -| node[anchor=west] {\color{red} F} (if1_F);
                \draw [arrow] (if1_T) -- (if2_1T);
                \draw [arrow] (if1_F) -- (if2_1F);
                \draw [arrow, color=green] (if2_1T) -| node[anchor=east] {\color{green} T} (if2_1T_T);
                \draw [arrow, color=red] (if2_1T) -| node[anchor=west] {\color{red} F} (if2_1T_F);
                \draw [arrow, color=green] (if2_1F) -| node[anchor=east] {\color{green} T} (if2_1F_T);
                \draw [arrow, color=red] (if2_1F) -| node[anchor=west] {\color{red} F} (if2_1F_F);
                \draw [arrow] (if_2_1T_T_path) -- (fail);

            \end{tikzpicture}
            \caption{Kontrollflussgraph für das Beispielprogramm}
            \label{fig:cfg}
        \end{figure}
        \item Leite alle möglichen Pfadbedingungen her.
        
        This can also be seen in the Figure~\ref{fig:cfg}, where the path constraints are shown in green boxes.
        \item Gibt es eine Belegung von \verb|a| und \verb|b|, die das Assert verletzt? Wenn ja: Welche?
        
        As shown in Figure~\ref{fig:cfg}, there is a path that leads to the assertion failure, which is the path where \verb|a > 0| and \verb|b == 0|. Therefore, any values of \verb|a| and \verb|b| that satisfy these conditions will violate the assertion. For example, \verb|a = 1| and \verb|b = 0| would lead to the assertion failure.
    \end{enumerate}
\end{ejercicio}