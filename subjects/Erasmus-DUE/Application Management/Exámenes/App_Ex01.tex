\documentclass[12pt]{article}

\input{../../../_assets/preambulo.tex}

\usetikzlibrary{arrows.meta, positioning, shapes.multipart}
\tikzset{
    git/commit/.style={
        circle, 
        draw, 
        minimum size=1.2cm, 
        font=\small\ttfamily
    },
    % Estilo base para refs
    git/ref/.style={
        draw,
        rectangle split,
        rectangle split parts=#1, 
        minimum width=1.5cm,
        font=\small\ttfamily,
        align=center,
        fill=white
    },
    % Valor por defecto para el argumento #1
    git/ref/.default=1,
    git/history/.style={
        -{Stealth}, 
        thick
    },
    git/pointer/.style={
        -{Stealth}, 
        dashed, 
        thick
    }
}



\begin{document}

    % 1. Foto de fondo
    % 2. Título
    % 3. Encabezado Izquierdo
    % 4. Color de fondo
    % 5. Coord x del titulo
    % 6. Coord y del titulo
    % 7. Fecha

    \input{../../../_assets/portada}
    \portadaExamenFotoDif{../../dueA4.jpg}{Application\\Management\\Exam I}{App. Management. Exam I}{MidnightBlue}{-8}{28}{2025-2026}{Arturo Olivares Martos}

    \begin{description}
        \item[Asignatura] Application Management.
        \item[Curso Académico] Winter Semester 2024-25.
        %\item[Grado] Grado en Matemáticas.
        %\item[Grupo] B.
        %\item[Profesor] José María Espinar García.
        %\item[Descripción] Parcial de los Temas 2 y 3.
        \item[Fecha] 13 de Febrero de 2025.
        % \item[Duración] 60 minutos.
    
    \end{description}
    \newpage
    

    \begin{ejercicio}[Application Lifecycle Management (ALM)]~
        \begin{enumerate}
            \item (1 Punkt) Nennen Sie vier Phasen des ALM, welche auch dem Wasserfallmodell zugeordnet werden können.
            
            Requirements, Design, Implementation, Testing, Deployment or Maintenance. Basically, all the phases of the software development lifecycle (SDLC) can be considered part of ALM, but the most commonly referenced ones are those mentioned above.
            \item (2 Punkte) Welche(n) Vorteil(e) bietet die Wahl einer permissiven Lizenz wie Apache~2.0 oder MIT?
            \begin{enumerate}
                \item Förderung der breiten Nutzung und Akzeptanz.
                \item Strikte Kontrolle über alle Modifikationen.
                \item Geringere Hürden für kommerzielle Nutzung.
                \item Verpflichtung zur Offenlegung aller Änderungen.
            \end{enumerate}

            \item (2 Punkte) Welche der folgenden Aussagen zum Application-Lifecycle-Management (ALM) trifft/treffen zu?
            \begin{enumerate}
                \item ALM umfasst neben Entwicklung auch Betriebs- und Wartungsprozesse.
                \item ALM ist nur relevant für agile Softwareprojekte.
                \item ALM setzt sich häufig aus kontinuierlichem Monitoring und Feedback zusammen.
                \item Ein zentrales Ziel von ALM ist die Transparenz über die gesamte Lebensdauer einer Software.
            \end{enumerate}

            The first and last statements are obviously correct. The second statement is also obviously wrong, as ALM is relevant for all types of software projects, not just agile ones. The third statement is also correct, as continuous monitoring and feedback are often key components of effective ALM practices. \textbf{Therefore, the correct answers are: a), c), and d).}

            \item (2 Punkte) Welche der folgenden Aussagen trifft/treffen auf die Shift-Left-Teststrategie zu?
            \begin{enumerate}
                \item Tests möglichst spät durchführen, damit mehr Zeit für die Entwicklung bleibt.
                \item Probleme möglichst früh erkennen und beheben, um Kosten zu senken.
                \item Den Testaufwand im Betrieb auf ein Minimum reduzieren.
                \item Nur kritische Funktionen in einer frühen Phase testen.
            \end{enumerate}

            The first and third statements are obviously incorrect, as the Shift-Left-Teststrategie emphasizes the importance of testing early in the development process to identify and address issues as soon as possible. The second statement is also obviously correct, as early detection and resolution of problems can indeed help reduce costs. The fourth statement is also incorrect, as the Shift-Left-Teststrategie encourages testing of all functions, not just critical ones, in an early phase to ensure overall software quality. \textbf{Therefore, the correct answer is: b).}

            \item (2 Punkte) Warum ist es wichtig, den gesamten Lebenszyklus einer Software zu betrachten?
            
            It is important to consider the entire lifecycle of software because it allows for developping a software that not only is of a higher quality, but also is more maintainable, scalable, and adaptable to changing requirements.
            
            \item (2 Punkte) Was versteht man unter 'Flakiness' bei Tests?
            
            ``Flaky'' Tests are tests that can produce different results (pass or fail) when run multiple times under the same conditions. This can be due to various factors such as timing issues, dependencies on external systems, or non-deterministic behavior in the code being tested. Flaky tests can lead to unreliable test results and can make it difficult to identify real issues in the software.
            
            \item (2 Punkte) Beschreiben Sie, welche Einfluss 'flaky' Tests auf eine CI/CD haben.
            
            Flaky tests can have a significant negative impact on CI/CD pipelines, as they can lead to false positives (tests that pass when there is actually a problem). This can therefore lead to a lack of trust in the test suite, making it harder for developers to identify and fix real issues in the code. Additionally, flaky tests can cause delays in the development process, as developers may need to spend time investigating and addressing the flaky tests instead of focusing on actual code changes.
            
            \item (4 Punkte) Nennen Sie vier Stakeholder, welche typischerweise in den ALM-Prozess involviert sind und beschreiben Sie diese kurz.
            \begin{itemize}
                \item Developper: They are responsible for writing the source code and implementing the features of the software.
                \item QA Team: They are responsible for testing the software to ensure it meets the required quality standards and is free of bugs. They should not be the same as the developers, as they need to have an independent perspective to effectively identify issues.
                \item Client: They are the ones who have commissioned the software and will be using it. They provide requirements and feedback throughout the development process to ensure the final product meets their needs.
                \item Bussiness Analyst: They study the market and the business needs to help define the requirements for the software.
            \end{itemize}
        \end{enumerate}
    \end{ejercicio}




    \newpage
    \begin{ejercicio}[Versionskontrolle]~
        \begin{enumerate}
            \item (2 Punkte) Welche der folgenden Vorteile bietet ein verteiltes Versionskontrollsystem?
            \begin{enumerate}
                \item Jeder Entwickler hat eine vollständige Kopie des Repositories.
                \item Änderungen werden automatisch mit allen anderen synchronisiert.
                \item Es gibt immer einen zentralen Server, der alle Änderungen speichert.
                \item Arbeiten an Branches können unabhängig voneinander erfolgen.
            \end{enumerate}


            The first and fourth statements are obviously correct. The second is obviously false, as changes are not automatically synchronized with all other developers in a distributed version control system (\verb|push| and \verb|pull| operations are required for synchronization). The third statement is also false, as distributed version control systems do not rely on a central server to store all changes; instead, each developer has a complete copy of the repository. \textbf{Therefore, the correct answers are: a) and d).}
            \item (2 Punkte) Welche Rolle spielen Hashes bei Git?
            \begin{enumerate}
                \item Sie identifizieren eindeutig jede Version einer Datei oder eines Commits.
                \item Sie verhindern Datenverlust bei Netzwerkausfällen.
                \item Sie ermöglichen es Entwicklern, Konflikte automatisch zu lösen.
                \item Sie gewährleisten die Integrität der gespeicherten Daten.
            \end{enumerate}

            The first and fourth statements are correct. The second statement is incorrect, as hashes have nothing to do with network failures. The third statement is also incorrect, as conflicts in Git should be resolved manually by developers, not automatically. \textbf{Therefore, the correct answers are: a) and d).}
            \item (6 Punkte) Diskutieren Sie die Vor- und Nachteile von Rebase vs. Merge in Bezug auf:
            \begin{itemize}
                \item Der Übersichtlichkeit der Historie
                
                In terms of history clarity, merge commits can make the history more complex and harder to read, especially if there are many branches and merges. On the other hand, rebasing creates a cleaner, linear history by applying commits on top of the target branch, which can make it easier to understand the sequence of changes.
                \item Des Konfliktmanagements
                
                Merge can lead to more complex conflict resolution, as it combines the histories of two branches, which may have diverged significantly. Rebase can simplify conflict resolution by applying commits one at a time, allowing developers to address conflicts in a more controlled manner.
                \item Der Teamabsprachen (z. B. wann force push nötig wird).
                
                Rebase can require force pushing if the branch has already been shared with others, which can lead to complications and potential data loss if not handled carefully. Merge does not require force pushing, as it creates a new commit that combines the changes from both branches without altering the existing commits. Therefore, teams need to have clear agreements on when to use rebase and how to handle force pushes to avoid issues in collaborative workflows.
            \end{itemize}

            \item (5 Punkte) Es wurde folgender Befehl ausgeführt: \verb|git checkout HEAD^2|. Auf welchen Commit zeigt \verb|HEAD|? Begründen Sie Ihre Antwort. In Figur~\ref{fig:commit-history} ist die Commit-Historie dargestellt, und in Listing~\ref{lst:head-history} die Historie von \verb|HEAD|.
            \begin{figure}
                \centering
                \begin{tikzpicture}[node distance=1.5cm]
                    % Commits
                    \node[git/commit] (9ca0fb) {\verb|9ca0fb|};
                    \node[git/commit, right=of 9ca0fb] (517f73) {\verb|517f73|};
                    \node[git/commit, above =of 517f73] (84a640) {\verb|84a640|};
                    \node[git/commit, above =of 84a640] (f59d4c) {\verb|f59d4c|};
                    \node[git/commit, right=of 84a640] (f2f27d) {\verb|f2f27d|};
                    \node[git/commit, below=of f2f27d, xshift=3cm] (15ce75) {\verb|15ce75|};

                    % HEAD
                    \node[git/ref, right=0.5cm of 15ce75] (HEAD) {\verb|HEAD|};

                    % Verbindungen
                    \draw[git/history] (517f73) -- (9ca0fb);
                    \draw[git/history] (84a640) -- (9ca0fb);
                    \draw[git/history] (f59d4c) -| (9ca0fb);
                    \draw[git/history] (f2f27d) -- (84a640);
                    \draw[git/history] (15ce75) |- (f59d4c);
                    \draw[git/history] (15ce75) -- (f2f27d);
                    \draw[git/history] (15ce75) -- (517f73);

                    \draw[git/pointer] (HEAD) -- (15ce75);

                \end{tikzpicture}
                \caption{Commit-Historie}
                \label{fig:commit-history}
            \end{figure}

            \begin{listing}
                \begin{minted}{text}
                    HEAD Historie:
                    15ce75 merge f2f27d, f59d4c
                    517f73 checkout
                    f2f27d commit
                    84a640 checkout
                    f59d4c commit
                    9ca0fb checkout
                \end{minted}
                \caption{\texttt{HEAD} Historie}
                \label{lst:head-history}
            \end{listing}

            The \verb|HEAD| is currently pointing to the commit \verb|15ce75|, which is a merge commit that has three parents:
            \begin{enumerate}
                \item Father 1: \verb|517f73|, which is the commit that was checked out before the merge.
                \item Father 2: \verb|f2f27d|, given that it is written first in the HEAD history
                \item Father 3: \verb|f59d4c|, given that it is written second in the HEAD history
            \end{enumerate}

                Therefore, the command \verb|git checkout HEAD^2| will move the \verb|HEAD| to the second parent of the current commit, which is \verb|f2f27d|. Thus, after executing the command, \verb|HEAD| will point to the commit \verb|f2f27d|.

            \item (4 Punkte) Ein Entwicklerteam verwendet Git für ein Webprojekt. Aus Versehen hat ein Teammitglied in einem früheren Commit eine Datei \texttt{.env} eingecheckt, in der sensible Zugangsdaten (API-Keys, Datenbankpasswörter) enthalten sind. Das ist dem Team erst nach einigen Tagen aufgefallen, nachdem bereits weitere Commits und Branches erstellt wurden. Das Repository ist öffentlich auf GitHub verfügbar. Die Git-Dokumentation beschreibt den Befehl \texttt{git revert} wie in Listing~\ref{lst:git-revert} dargestellt.
            \begin{listing}
                \begin{minted}{text}
1. git revert [--no-edit] [-n] [-m <parent-number>] [-s] [-S[keyid]] <commit>...
2. git revert [--continue | --skip | --abort | --quit]

> Wenn ein oder mehrere bestehende Commits angegeben werden, werden die durch die zugehörigen Patches eingeführten Änderungen rückgängig gemacht. Dabei entstehen neue Commits, die diesen Vorgang festhalten. Voraussetzung dafür ist, dass dein Working Tree sauber ist.
                \end{minted}
                \caption{Git Revert Befehl}
                \label{lst:git-revert}
            \end{listing}
            Begründen Sie, wie und ob dieser Befehl dazu beitragen kann, das Problem zu beheben. Sollten der Befehl nützlich sein, geben Sie außerdem den abgeätzten Befehl an, welcher das Problem behebt.

            It depens on the final goal of the team.
            \begin{itemize}
                \item The only thing that \texttt{git revert} can do is to create a new commit that undoes the changes introduced by the commit that added the \texttt{.env} file. It should be done by executing the command \texttt{git revert <commit-hash>}, where \texttt{<commit-hash>} is the hash of the commit that added the \texttt{.env} file. This will create a new commit that removes the \texttt{.env} file from the repository's history.
                \item However, it should be noted that, even though the \texttt{.env} file will be removed from the current state of the repository, it will still be present in the commit history. Therefore, if the goal is to completely remove the sensitive data from the repository, \texttt{git revert} alone will not be sufficient. With the \verb|git checkout| command, the team can move to the commit before the one that deleted the \texttt{.env} file, and then obtain the file from there. This means that the sensitive data will still be accessible through the commit history, which can be a security risk if the repository is public.
            \end{itemize}

            \item (2 Punkte) Reicht das Entfernen aus Git aus, um die Sicherheit vollständig wiederherzustellen? Begründen Sie Ihre Antwort.
            
            It depends on what does ``removing from Git'' mean.
            \begin{itemize}
                \item If it means just deleting the file from the current state of the repository, then it is not sufficient to fully restore security, as the sensitive data will still be present in the commit history.
                \item If it means actually deleting the file from the entire commit history (deleting also the blob that contains the file's content), then even though it would remove the sensitive data from the repository, it may not be sufficient to fully restore security, as other people could have gained access to the sensitive data while it was still present in the repository, and they could have made copies of it. Additionally, if the repository is public, there may be other copies of the repository (e.g., forks) that still contain the sensitive data, which can also pose a security risk.
                
                In this case, the team should also consider revoking any compromised credentials and generating new ones, as well as monitoring for any unauthorized access that may have occurred while the sensitive data was exposed.
            \end{itemize}
            
            \item (2 Punkte) Welche Maßnahmen würden Sie dem Team vorschlagen, um solche Vorfälle in Zukunft zu vermeiden? Nennen Sie mindestens zwei.
            
            There are several measures that the team can take to prevent such incidents in the future:
            \begin{itemize}
                \item Implementing a pre-commit hook that checks for sensitive files (e.g., \texttt{.env} files) and prevents them from being committed to the repository.
                \item Adding these sensitive files to the \texttt{.gitignore} file to ensure that they are not accidentally committed to the repository.
                \item Providing training and awareness to the team about the importance of keeping sensitive data out of version control and the potential risks associated with exposing such data.
                \item Using secret management tools to securely store and manage sensitive information, rather than keeping it in files that could be accidentally committed to version control.
                \item Using 2FA (Two-Factor Authentication) for accessing the repository to add an extra layer of security in case credentials are compromised.
            \end{itemize}
        \end{enumerate}
        
    \end{ejercicio}


    \newpage
    \begin{ejercicio}[Deployment und Delivery]~
        \begin{enumerate}
            \item (2 Punkte) Welche der folgenden Aussagen trifft/treffen auf Continuous Deployment zu?
            \begin{enumerate}
                \item Jede Codeänderung durchläuft manuelle Tests, bevor sie deployed wird.
                \item Jede erfolgreich getestete Codeänderung wird automatisch in Produktion deployed.
                \item Continuous Deployment erfolgt nur bei erfolgreichen Software-Releases.
                \item Continuous Deployment setzt keine vollständige Automatisierung voraus.
            \end{enumerate}

            The first statement is incorrect, as Continuous Deployment emphasizes automation and does not require manual testing for every code change. The second statement is correct, as Continuous Deployment involves automatically deploying every successfully tested code change to production. The third statement is also correct because, if any of the code changes fail the tests, they will not be deployed to production. The fourth statement is incorrect, as Continuous Deployment relies heavily on automation to ensure that code changes are deployed efficiently and reliably. \textbf{Therefore, the correct answers are: b) and c).}

            \item (2 Punkte) Welche der folgenden Aussagen zu Canary Releases ist korrekt?
            \begin{enumerate}
                \item Alle Benutzer erhalten sofort die neue Version.
                \item Die neue Version wird erst einer kleinen Nutzergruppe zur Verfügung gestellt.
                \item Ein Rollback ist nicht möglich.
                \item Canary Releases sind nicht für sicherheitskritische Systeme geeignet.
            \end{enumerate}


            The first and third statements are incorrect, and the second statement is correct. Regarding the fourth statement, Canary Releases are indeed suitable for secure systems, as they allow for controlled rollouts and quick rollbacks in case of issues. \textbf{Therefore, the correct answer is: b).}

            \item (3 Punkte) Welche Herausforderungen müssen Unternehmen bei der Umstellung auf automatisiertes Deployment berücksichtigen?
            
            Enterprises need to consider several challenges when transitioning to automated deployment, including:
            \begin{itemize}
                \item Ensuring that there are enough and robust automated tests in place to catch any issues before they reach production.
                \item Rapid Incremental Deployment: Using also the agile principles to the deployment process, letting the team not stop the development process to wait for the automated scripts to be ready.
                \item Cultural Shift: Encouraging a culture of collaboration and shared responsibility for the deployment process among development, operations, and other teams.
                \item Security Concerns: Implementing proper security measures to protect the deployment pipeline and the production environment from potential threats.
                \item Tooling and Infrastructure: Investing in the right tools and infrastructure to support automated deployment, which may require significant changes to existing processes and systems.
            \end{itemize}
            
            \item (3 Punkte) Continuous Integration, Continuous Delivery und Continuous Deployment sind zentrale Prinzipien moderner Softwareentwicklung. Erklären Sie die Unterschiede dieser Konzepte.
            
            \begin{itemize}
                \item Continuous Integration (CI) focuses on automatically integrating code changes from multiple developers into a shared repository. The main goal is to detect integration conflicts early and ensure that the codebase remains in a healthy state. In addition, it focuses on building and testing the code automatically whenever changes are made, to catch issues as early as possible.
                \item Continuous Delivery (CD) builds upon CI by ensuring that the code is always in a deployable state. It involves automating the release process so that code can be deployed to production at any time with minimal manual intervention. However, the actual deployment to production may still require manual approval, allowing for additional checks and controls before the code goes live.
                \item Continuous Deployment takes Continuous Delivery a step further by automatically deploying every successfully tested code change to production without requiring manual approval. This approach emphasizes rapid and frequent releases, allowing for faster feedback and iteration. However, it also requires a high level of confidence in the automated testing and deployment processes to ensure that only stable and reliable code is deployed to production.
            \end{itemize}
            
            \item (2 Punkte) Nennen Sie zwei Vorteile und zwei Herausforderungen von CI/CD Pipelines:
            \begin{itemize}
                \item Advantages:
                \begin{itemize}
                    \item Faster Feedback: CI/CD pipelines provide rapid feedback on code changes, allowing developers to identify and address issues quickly.
                    \item Improved Quality: By automating testing and deployment processes, CI/CD pipelines can help ensure that only high-quality code is released to production.
                \end{itemize}
                \item Challenges:
                \begin{itemize}
                    \item Initial Setup Complexity: Setting up a CI/CD pipeline can be complex and time-consuming, requiring significant effort to configure the necessary tools and processes.
                    \item Maintenance Overhead: CI/CD pipelines require ongoing maintenance to ensure they continue to function effectively, which can be resource-intensive and may require dedicated personnel.
                \end{itemize}
            \end{itemize}
            
            \item (6 Punkte) Sie haben eine Binary (MagicWeb), welche einen Webserver auf Port 8080 startet. Diese Binary haben Sie frisch erstellt. Da diese Binary Ihre kompletten Geheimnisse enthält, möchten Sie nicht, dass die Binary im Internet verfügbar ist, daher haben Sie dafür gesorgt, dass Ihr Rechner nicht mit dem Internet verbunden ist. Sie möchten diese Binary aber zweimal ausführen, deshalb haben Sie Docker gerade frisch installiert. Dazu wollen Sie die Docker-Compose Datei wie in Listing~\ref{lst:docker-compose} nutzen.
            \begin{listing}
                \begin{minted}{yaml}
services:
    magicweb1:
        image: MagicWeb
        ports:
            - "8081:8080"
        container_name: magicweb_container1
    magicweb2:
        image: MagicWeb
        ports:
            - "8082:8080"
        container_name: magicweb_container2
                \end{minted}
                \caption{Docker-Compose Datei}
                \label{lst:docker-compose}
            \end{listing}

            Wenn Sie nun \texttt{docker compose up} ausführen, beschreiben Sie was nun passiert. Sollte der Befehl nicht funktionieren, beschreiben Sie, welche Schritte man vornehmen müsste, um das Problem zu beheben.

            When you run \texttt{docker compose up}, Docker will attempt to start two containers based on the \texttt{MagicWeb} image.
            \begin{enumerate}
                \item It will first check if the \texttt{MagicWeb} image is available locally. Given that you have just installed Docker and have not pulled or built the image, it will not be available locally.
                \item Docker will try to pull the \texttt{MagicWeb} image from a Docker registry (e.g., Docker Hub). However, since your computer is not connected to the internet, this will fail, and you will receive an error message indicating that the image cannot be found or pulled.
            \end{enumerate}

            Therefore, the \texttt{docker compose up} command will not work as expected due to the lack of internet connectivity and the absence of the \texttt{MagicWeb} image locally. To fix this issue, you need to previously build the \texttt{MagicWeb} image locally using a Dockerfile that defines how to build the image from your binary. This can be done by creating a Dockerfile with the necessary instructions to copy the binary into the image and set up the environment for it to run. Once you have built the image locally, you can then run \texttt{docker compose up} successfully, as it will find the \texttt{MagicWeb} image in your local Docker registry and start the containers as defined in the Docker-Compose file.
        \end{enumerate}
        
    \end{ejercicio}





    \newpage
    \begin{ejercicio}[Secure Software Development]~
        \begin{enumerate}
            \item (2 Punkte) Welche der folgenden Aussagen trifft/treffen auf Netflix Chaos Monkey zu?
            \begin{enumerate}
                \item Es simuliert und testet zufällige Ausfälle von Systemen, um die Infrastruktur zu verbessern.
                \item Es dient dazu, sensible Daten in Cloud-Umgebungen zu verschlüsseln und vor Bedrohungen zu schützen.
                \item Es ist ein Tool zur automatisierten Schwachstellenanalyse in Webanwendungen.
                \item Es analysiert den Softwarecode auf unsichere Abhängigkeiten und veraltete Bibliotheken.
            \end{enumerate}

            \item (2 Punkte) Welche der folgenden Aussagen trifft/treffen zu?
            \begin{enumerate}
                \item Mutational Fuzzing ist eine Technik, bei der Eingaben durch gezielte synthetische Constraints generiert werden.
                \item Symbolic Execution eignet sich besonders für Programme mit vielen Verzweigungen.
                \item Coverage-Guided Fuzzing nutzt Feedback über erreichte Code-Pfade, um Eingaben systematisch zu generieren.
                \item Symbolic Execution kann auch auf Binärprogramme angewendet werden, ohne zusätzliche Modellierung.
            \end{enumerate}

            The first statement is incorrect, as Mutational Fuzzing is a technique that generates inputs by mutating existing valid inputs, rather than using targeted synthetic constraints. The second statement is also incorrect given the Path Explosion problem, which makes Symbolic Execution less effective for programs with many branches. The third statement is correct, as Coverage-Guided Fuzzing uses feedback about which code paths have been executed to systematically generate new inputs that explore untested paths. The fourth statement is also incorrect, as applying Symbolic Execution to binary programs typically requires additional modeling to handle the complexities of binary code and its execution environment. \textbf{Therefore, the correct answer is: c).}

            \item (2 Punkte) Warum ist Fuzzing ein effektives Mittel zur Identifizierung von Sicherheitslücken?
            
            Fuzzing is an effective method for identifying security vulnerabilities because it can automatically generate a large number of test inputs, including unexpected or malformed inputs, that may trigger edge cases or hidden bugs in the software. This can help uncover vulnerabilities that may not be easily found through manual testing or code review. Additionally, fuzzing can be used to test the robustness and resilience of software against various types of input, which is crucial for identifying potential security weaknesses.
            
            \item (3 Punkte) Beschreiben Sie, wie Symbolische Ausführung (\verb|SymExe|) mit einem SMT-Solver wie Z3 systematisch Pfade in einem Programm analysiert.
            
            Symbolic Execution (SymExe) is a technique used to systematically analyze the paths in a program by treating inputs as symbolic variables rather than concrete values. When a program is executed symbolically, it generates path constraints based on the conditions encountered during execution. These constraints represent the conditions under which certain paths in the program would be taken. A SMT (Satisfiability Modulo Theories) solver like Z3 can then be used to solve these constraints to determine if there are any inputs that would lead to specific paths being executed. For example, if SymExe encounters a conditional statement (e.g., \verb|if (x > 5)|), it would generate a path constraint (e.g., \verb|x > 5|) for the true branch and (e.g., \verb|x <= 5|) for the false branch. Z3 can then be used to find concrete values for \verb|x| that satisfy these constraints, allowing the analysis to explore different execution paths and identify potential vulnerabilities or bugs in the program.
            
            \item (2 Punkte) Falls die symbolische Ausführung einen kritischen Pfad entdeckt, welche Informationen würde Z3 dazu typischerweise liefern?
            
            If symbolic execution discovers a critical path, Z3 would typically provide information about the specific input values that would trigger that path. This could include the values of symbolic variables that satisfy the path constraints, which can help developers understand how to reproduce the issue and identify potential vulnerabilities in the code. 
            
            \item (4 Punkte) Nennen Sie zwei Security-Testing-Methoden und geben Sie für jede ein Beispiel.

            
            \item (4 Punkte) Wie verbessert eine mehrstufige Zertifikatskette die Sicherheit?
            
                A multi-level certificate chain improves security by providing a hierarchical structure of trust. In a certificate chain, each certificate is signed by a trusted authority, and the chain of trust extends from the end-entity certificate (e.g., a website's SSL certificate) up to a root certificate authority (CA). This structure allows for better management of trust and revocation. If a certificate in the chain is compromised or needs to be revoked, it can be done without affecting the entire chain, as long as the root CA remains secure. Additionally, multi-level certificate chains can provide additional layers of validation and authentication, making it more difficult for attackers to forge certificates or impersonate legitimate entities.
            

            
            \item Was ist binary provenance und was kann passieren wenn dies nicht gewährt ist? Nennen Sie zwei Fälle.
            
                Binary provenance refers to the ability to trace the origin and history of a binary file, including information about how it was built, what source code it was derived from, and any dependencies it may have. If binary provenance is not provided, it can lead to several issues:
                \begin{itemize}
                    \item Security Risks: Without binary provenance, it becomes difficult to verify the authenticity and integrity of a binary file. This can lead to security risks, as malicious actors could potentially distribute tampered or malicious binaries without detection.
                    \item Compliance Issues: In certain industries, there may be regulatory requirements for software supply chain transparency. Without binary provenance, organizations may struggle to meet these compliance requirements, which could result in legal consequences or loss of trust from customers and partners.
                \end{itemize}
        \end{enumerate}
        
    \end{ejercicio}
\end{document}