\chapter{Version Control System (VCS)}

\begin{definicion}[Version Control System (VCS)]
    A Version Control System (VCS) is a software tool that helps to manage changes to source code over time. It keeps track of every modification made to the code, also allowing to revert to previous versions if needed.
\end{definicion}

\section{Types of VCS}

There are three main types of VCS:
\begin{itemize}
    \item Local VCS: It stores all the changes in a local database on the developer's computer. It is simple to use, but it does not provide collaboration features. One example is GNU RCS (Revision Control System).
    \item Centralized VCS: It uses a central server to store all the changes. Follows a client-server architecture.
    \begin{description}
        \item[Advantages] Clear control access, correct backup of big files and locking mechanism.
        \item[Disadvantages] Single point of failure, limited offline capabilities and the possibility of forgetting to release the locks. 
    \end{description}

    Only the original file and then each specific changes (deltas) are stored, not every version of the file. This saves space but depends on the whole set of deltas to reconstruct a specific version. One example is Subversion (SVN).
    \item Distributed VCS: It allows every developer to have a complete copy (including history) of the repository on their local machine. This provides better collaboration features and allows developers to work offline.
\end{itemize}

In the following section, we will focus on Distributed VCS, and specially on one of the most popular ones: Git.

\section{Git}

Git is a distributed version control system that is widely used in the software development industry. Opposite to the delta-based approach of the centralized VCS, Git uses a \emph{snapshot-based} approach. It keeps a list of the whole snapshots of the filesystem at specific points in time. Almost every operation in Git is performed \emph{locally}, which makes it really fast. Given that the history is stored locally, it allows to work and to restore previous versions even when offline. It uses \emph{Hashing} (SHA-1) to identify every single commit, ensuring the integrity of the codebase.\\

Git has some diffeent states for each file, which are stored in three different areas:
\begin{itemize}
    \item \ul{Modified} (Stored in the working directory): The file has been changed but not yet staged for commit (not registered in the repository).
    \item \ul{Staged} (Stored in the staging area): The file has been modified and is marked to be included in the next commit.
    \item \ul{Committed} (Stored in the local repository, \verb|.git| folder): The file has been saved in the local repository.
\end{itemize}

Some important Git commands are the following ones:
\begin{itemize}
    \item \verb|git init|: Initializes a new Git repository (creates the \verb|.git| folder).
    \item \verb|git clone <repo_url>|: Clones an existing repository from a remote server to the local machine.
    \item \verb|git add <file>|: Stages a file for commit. It also lets tracking new files and indicating when a file conflict has been resolved.
    
    Using the option \verb|-A| stages all the changes (new, modified and deleted files).
    \item \verb|git commit -m "message"|: Commits the staged changes to the local repository with a descriptive message.
    \begin{itemize}
        \item \verb|git commit --amend|: It modifies the last commit by adding the currently staged changes to it. It is useful when you forget to stage some changes before committing, or when you want to fix a mistake in the last commit (e.g., a typo in the code, a missing file, etc). It should be noted that the hash of the last commit will change after amending it. It should be used with the option \verb|--no-edit| if you want to keep the same commit message, or with the option \verb|-m "new message"| if you want to change the commit message.
    \end{itemize}
    \item \verb|git status|: Shows the current status of the working directory and staging area. Indicates which files are untracked, modified, deleted or staged for commit.
    \begin{observacion}
        All the files that are not tracked will always appear in red when using \verb|git status|. Sometimes they are intended to be untracked (e.g., temporary files, build artifacts, etc). In that case, they can be added to the \verb|.gitignore| file to avoid them appearing in the status. That will make Git ignore them.
    \end{observacion}
    \item \verb|git diff|: Shows the differences between files in different states (working directory, staging area, last commit). Has different options to compare specific states:
    \begin{itemize}
        \item \verb|git diff|: Working directory vs Staging area.
        \item \verb|git diff --staged|: Staging area vs Last commit.
        \item \verb|git diff HEAD|: Working directory vs Last commit.
    \end{itemize}

    \item \verb|git log|: Displays the commit history of the repository. Using the option \verb|-p| shows the differences introduced in each commit.
    
    \item \verb|git checkout <commit_hash>|: Switches to a specific commit, allowing to view the state of the repository at that point in time.
\end{itemize}

In addition, when referencing a commit, Git allows to use some special notations:
\begin{itemize}
    \item \verb|<commit_hash>^[<n>] |: Refers to the $n$-th parent of the specified commit (for instance, when merging, more than a parent may appear). If $n$ is not provided, it defaults to 1, referring to the first parent.
    \item \verb|<commit_hash>~[<n>] |: Refers to the $n$-th ancestor of the specified commit. It follows the first parent of each commit, so it is useful to refer to commits in a linear history. If $n$ is not provided, it defaults to 1, referring to the immediate parent.
\end{itemize}

\subsection{Git Bisect}

In this section, we introduce a new command, \verb|git bisect|, which is used to find the specific commit that introduced a bug or issue in the codebase. A whole section is needed, as it is a really useful command that can save a lot of time when debugging. It uses a binary search algorithm ($O(\log n)$) to efficiently narrow down the range of commits that may have introduced the bug. The workflow for using \verb|git bisect| is as follows:
\begin{enumerate}
    \item Initialize the bisect process.
    \begin{enumerate}[label=\arabic{enumi}.\arabic*]
        \item \verb|git bisect start|: Initializes the bisect process.
        \item \verb|git bisect bad|: Marks the current commit as bad (the commit where the bug is present).
        \item \verb|git bisect good <commit_hash>|: Marks a specific commit as good (a commit where the bug is not present).
    \end{enumerate}

    \item Locate the commit that introduced the bug.
    \begin{enumerate}
        \item Git will automatically check out a commit in the middle of the range between the good and bad commits. The developer needs to test this commit to determine if it is good or bad.
        \item Based on the test result, the developer will mark the commit:
        \begin{itemize}
            \item \verb|git bisect good|: If the commit is good, it will narrow down the search to the range between this commit and the bad commit.
            \item \verb|git bisect bad|: If the commit is bad, it will narrow down the search to the range between this commit and the good commit.
        \end{itemize}
        \item This process is repeated until Git identifies the specific commit that introduced the bug.
    \end{enumerate}

    During the whole process, the following command are useful:
    \begin{itemize}
        \item \verb|git bisect log|: Shows the log of the bisect process, including the commits that have been marked as good or bad.
        \item \verb|git bisect visualize --oneline|: Visualizes the bisect process, showing the commits that are still not tested, and where the \verb|HEAD| is currently located.
    \end{itemize}

    This whole process can be automated by using the following command:
    \begin{itemize}
        \item \verb|git bisect run <script>|: This command automates the bisecting process by running a specified script that tests each commit. The script should return a zero exit code if the commit is good and a non-zero exit code (normally 1) if the commit is bad. This allows to quickly identify the bad commit without manual intervention.
    \end{itemize}
    \item End the bisect process.
    \begin{itemize}
        \item \verb|git bisect reset|: After finding the bad commit, this command is used to end the bisect process and return to the original state of the repository (the branch and commit that were checked out before starting the bisect). It is important to use this command to clean up the bisect state and avoid any confusion in future operations.
    \end{itemize}
\end{enumerate}

This command is used in the Exercise~\ref{ex:git_bisect}, so we refer to that exercise for a practical example of how to use \verb|git bisect|.

\subsection{Git LFS}

Git Large File Storage (Git LFS) is an extension for Git that is designed to handle large files more efficiently. Given that Git is based on snapshots, storing large files directly in the repository can lead to repeated storage of the same file in different commits, which can quickly bloat the repository size. Git LFS solves this problem by replacing large files with lightweight references in the Git repository. Instead of storing the actual file content in the repository, Git LFS stores a pointer to the file in the Git repository and keeps the actual file content in a separate storage location. It is especially useful for binary files (e.g., images, videos, audio files, \verb|pptx|, etc).\\

Some important Git LFS commands are the following ones:
\begin{itemize}
    \item \verb|git lfs install|: Installs Git LFS in the local repository.
    \item \verb|git lfs track "<file_pattern>"|: Tracks files matching the specified pattern with Git LFS.
    \item \verb|git lfs ls-files|: Lists the files that are being tracked by Git LFS.
\end{itemize}

\subsection{Branching}

Branching is a powerful feature in Git that allows developers to create separate lines of development within a repository. This enables multiple developers to work on different features or bug fixes simultaneously without interfering with each other's work. Each branch represents an independent line of development, allowing changes to be made in isolation. Once the changes in a branch are complete and tested, they can be merged back into the main branch (usually called \verb|main| or \verb|master|).\\


In order to explain branching, we need to define the concept of \emph{HEAD}.
\begin{definicion}[\emph{HEAD} Pointer]
    The \verb|HEAD| pointer is a reference to the current commit that the working directory is based on (therefore, it allows modifiers such as \verb|HEAD^| or \verb|HEAD~|). It indicates the current position in the repository's history. Some important aspects about the \verb|HEAD| pointer are the following ones:
    \begin{itemize}
        \item \verb|@| alone is a shorthand for \verb|HEAD|, so it can be used interchangeably.
        \item \verb|HEAD@{n}| refers to the position of \verb|HEAD| $n$ moves ago. For instance, \verb|HEAD@{1}| refers to the previous position of \verb|HEAD| before the last change (e.g., before the last checkout, merge, rebase, etc).
    \end{itemize}
\end{definicion}

Some important commands related to branching are the following ones:
\begin{itemize}
    \item \verb|git branch <branch_name>|: Creates a new branch with the specified name that points to the current commit. With the option \verb|-d|, it deletes the specified branch (if it has been merged).
    \item \verb|git checkout <branch_name>|: Switches to the specified branch, updating the working directory to reflect the state of that branch. It then also updates the \verb|HEAD| pointer to point to the new branch (the latest commit of that branch). With the option \verb|-b|, it creates a new branch and switches to it in a single command.
\end{itemize}

As explained with the \verb|HEAD| pointer, the names of branches are just pointers to specific commits (the latest commit of that branch). Therefore, modifiers such as \verb|<branch_name>^| or \verb|<branch_name>~| can be used to refer to commits in the history of that branch. \verb|<branch_name>@{n}| can also be used to refer to the position of the branch pointer $n$ moves ago.


\subsection{Branch Integration}
When the development in a branch is complete, it is often necessary to integrate the changes back into another branch (usually the \verb|main| or \verb|master| branch). There are two main methods for integrating branches in Git: merging and rebasing.
\begin{observacion}
    Given that understanding how the git tree will be after the integration is difficult, \href{https://git-school.github.io/visualizing-git/}{\color{blue}\ul{this tool}} can be used to visualize the effects of merging and rebasing.
\end{observacion}
\subsubsection{Merging}

The main command is the following one:
\begin{itemize}
    \item \verb|git merge <branch_name>|: Merges the specified branch into the current branch. It combines the changes from both branches, creating a new commit that represents the merged state.
\end{itemize}

There are two main strategies for merging branches:
\begin{itemize}
    \item Fast-Forward Merge: If the current branch has not diverged from the branch being merged, Git simply moves the \verb|HEAD| pointer forward to the latest commit of the merged branch. No new commit is created in this case.
    \item Recursive Merge: If the branches have diverged, Git creates a new commit that combines the changes from both branches. This new commit has two parent commits: one from each branch.
\end{itemize}

In the latter strategy, conflicts may arise if the same lines of code have been modified in both branches. Git will mark these conflicts in the affected files, and it is the developer's responsibility to resolve them manually before completing the merge. They can use \verb|git status| to see which files have conflicts and need to be resolved. After resolving the conflicts, the developer can stage the changes and complete the merge by committing the changes.

\subsubsection{Rebasing}

This strategy uses the following command:
\begin{itemize}
    \item \verb|git rebase <branch_name>|: Reapplies the commits from the current branch on top of the specified branch. It effectively moves the entire branch to start from the latest commit of the specified branch. With the option \verb|--continue|, it continues the rebase process after resolving conflicts.
\end{itemize}

After rebasing, the commit history appears linear, and therefore a simple fast-forward merge can be performed to integrate the changes into the target branch.\\

When rebasing, the commit history is rewritten, which can make it appear cleaner and more linear. However, the details about the mistakes committed during the development in the feature branch may be lost. In addition, it is dangerous to rebase branches that have already been pushed to a remote repository, as it can lead to confusion and conflicts for other developers working on the same branch, as their local copies will have a different history than the rebased branch.

\subsection{Git Hooks}

Git hooks are scripts that are automatically executed by Git before or after certain events, such as committing changes, merging branches, or pushing to a remote repository. They allow developers to customize and automate various aspects of their Git workflow. Git hooks are stored in the \verb|.git/hooks| directory of a Git repository. Each hook is a separate script file that corresponds to a specific event. Some common Git hooks include:
\begin{itemize}
    \item \ul{\texttt{pre-commit}}: Executed before a commit is created. It can be used to perform checks on the code (e.g., run tests, check code style, etc) and prevent the commit if any issues are found.
    \item \ul{\texttt{post-commit}}: Executed after a commit is created. It can be used to send notifications, update documentation, or trigger other actions.
    \item \ul{\texttt{pre-push}}: Executed before changes are pushed to a remote repository. It can be used to run tests or perform other checks to ensure that the code being pushed meets certain criteria.
\end{itemize}
As a useful aspect, if any of the scripts ends with a non-zero exit code (denoting an error), if it was a pre- hook, the action that triggered the hook will be aborted. It garantees that certain conditions are met before proceeding with the action.


\section{Distributed Git}

Until this point, we have only talked about local operations. To collaborate with other developers, it is necessary to use remote repositories.
\subsection{Remote Repositories}

A remote repository is a version of the repository that is hosted on a remote server (GitHub, GitLab, Bitbucket, etc.). It allows multiple developers to collaborate on the same codebase. All developers should synchronize their local repositories with the remote repository to share changes and keep their code up to date. When more than one developer is working on the same codebase, conflicts may arise if two developers modify the same lines of code in different ways. Some important commands to interact with remote repositories are the following ones:
\begin{itemize}
    \item \verb|git remote add <name> <url>|: Adds a new remote repository with a specific name (e.g., \verb|origin|).
    \item \verb|git push <remote> <branch>|: Pushes the local commits to the specified remote repository and branch.
    \item \verb|git fetch <remote>|: Fetches the latest changes from the specified remote repository without merging them into the local branch.
    \item \verb|git pull <remote> <branch>|: Fetches and merges changes from the specified remote repository and branch into the local branch.
\end{itemize}

\subsection{Collaboration Workflows}
% // TODO: Memorizar

There are different collaboration workflows that teams can follow when using Git, depending on their preferences and project requirements. In the following, we describe three common workflows.

\subsubsection{Centralized Workflow}
The repository has a single central shared repository. All developers clone this repository, make changes in their local copies, and then push their changes back to the central repository. When more than one developer changes the same lines of code, conflicts may arise during the push operation, which need to be resolved before the changes can be successfully pushed.\\
This workflow is simple and easy to understand, making it suitable for small teams or projects with straightforward collaboration needs.

\subsubsection{Integration Manager Workflow}

In this workflow, there are two types of developers:
\begin{itemize}
    \item \ul{Integration Manager}: He is the responsible and manteiner of the project.
    \item \ul{Contributors}: They suggest the integration managers the changes they want to make to the codebase.
\end{itemize}

As well as the two types of developers, there are also two types of repositories:
\begin{itemize}
    \item \ul{Blessed Repository}: It is maintained by the integration manager. It is the main repository where all the changes are eventually integrated, and it is considered the authoritative source of the codebase.
    \item \ul{Developper Repositories}: They are maintained by the contributors. Each contributor has their own repository where they can make changes and experiment with new features. Each developper has their public repository and its local copy.
\end{itemize}

The workflow works as follows:
\begin{enumerate}
    \item The integration manager creates the blessed repository, and make it public.
    \item Each contributor clones the blessed repository to create their own developper repository (that is, a fork of the blessed repository).
    \item Contributors make changes in their local copies and push them to their developper repositories.
    \item When a contributor wants to suggest changes to the blessed repository, they email the integration manager asking him to make those changes (this is typically done through a pull request).
    \item The integration manager adds the contributor's repository as a remote, fetches the changes, reviews them, and if everything is fine, merges them into their local blessed repository.
    \item Finally, the integration manager pushes the updated blessed repository to the remote server, so that all contributors can access the latest changes.
\end{enumerate}

This workflow allows for better control and review of changes, as the integration manager can carefully evaluate each contribution before integrating it into the main codebase. It is suitable for larger projects with multiple contributors.

\subsubsection{Dictator and Lieutenants Workflow}

This workflow is similar to the Integration Manager Workflow, but with a hierarchical structure. In this case, a new upper role is introduced: there are more than one integration managers, called \emph{lieutenants}, and they report to a single \emph{dictator} (the main integration manager). Each lieutenant is responsible for a specific area of the codebase and manages contributions related to that area.\\

The workflow works as follows:
\begin{enumerate}
    \item Each contributor works on their own branch created for their feature or bug fix.
    \item When needed, the lieutenants merge the branches of the contributors into their own master's branches.
    \item When needed, the dictator merges the master's branches of the lieutenants into his own master's branch.
    \item Finally, the dictator pushes the updated blessed repository to the remote server, so that all contributors can access the latest changes.
\end{enumerate}

This workflow allows for better organization and management of contributions, as each lieutenant can focus on their specific area of expertise. It is suitable for large projects with multiple teams working on different aspects of the codebase. For instance, the Linux kernel development follows this workflow.

\section{Git Internals}

Git is built around a few fundamental concepts that enable its powerful version control capabilities. Understanding these concepts can help developers use Git more effectively and troubleshoot issues when they arise.

\subsection{Objects}

Git stores all its data in a simple key-value database, where the key is a SHA-1 hash of the content, and the value is the actual content. There are three main types of objects in Git:
\begin{itemize}
    \item \ul{Blob}: It represents the content of a file. It does not contain any \emph{metadata} (e.g., filename, permissions, etc).
    \item \ul{Tree}: It represents a directory. It contains references to blobs (files) and other trees (subdirectories), along with their names and \emph{permissions}.
    \item \ul{Commit}: It represents a snapshot of the repository at a specific point in time. It contains:
    \begin{itemize}
        \item A reference to a tree object that represents the state of the repository at that commit (the root tree).
        \item References to parent commit(s) (the previous commit(s) in the history).
        \item Metadata such as the author, committer, timestamp, and commit message.
    \end{itemize}
\end{itemize}

All of the objects are stored in the \verb|.git/objects| directory. There, you can find subdirectories named with the first two characters of the SHA-1 hash, and inside those subdirectories, you can find files named with the remaining 38 characters of the hash. Git uses a combination of compression and delta encoding to store these objects efficiently, minimizing disk space usage. To see the objects stored in a Git repository, some useful commands are:
\begin{itemize}
    \item \verb|git cat-file -t <object_hash>|: Displays the type of the specified object (blob, tree, commit, etc).
    \item \verb|git cat-file -p <object_hash>|: Displays the content of the specified object.
    \item \verb|git ls-tree <tree_hash>|: Lists the contents of the specified tree object.
    \item \verb|git show <commit_hash>|: Displays the details of the specified commit, including the commit message, author, date, and the changes introduced in that commit.
\end{itemize}

In all the cases, the \verb|<object_hash>| is the SHA-1 hash of the object you want to inspect. Normally the first few characters of the hash are enough to uniquely identify the object.

\subsection{Git Filesystem-Check}

In the following section, a new command is presented, \verb|git fsck|, which is used to verify the integrity of the Git repository. It checks the connectivity and validity of the objects in the repository, ensuring that there are no corrupted or missing objects. An important option is the following:
\begin{itemize}
    \item \verb|git fsck --lost-found|: Sometimes, files may be accidentally deleted or become unreachable due to various reasons (e.g., a commit is removed, a branch is deleted, etc). However, if those files were sometime staged, they are not completely lost, as their blob is still located in the \verb|.git/objects| directory. However, detecting them can be difficult (there may be many objects in that folder).
    
    This option allows to find those lost objects and recover them. It creates two new directories, \verb|.git/lost-found/commit| and \verb|.git/lost-found/other|, where it places the lost commits and other objects (e.g., blobs), respectively. The files in those directories are named with their SHA-1 hash, and they can be inspected using the commands described in the previous section.
\end{itemize}