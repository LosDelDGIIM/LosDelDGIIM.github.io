\section{Deployment}

\begin{ejercicio}
    Die \emph{Echtzeit-Messaging-App} für den Campus der  ``Universität der Zukunft'' soll bereitgestellt werden. Die App soll zunächst auf Android-Telefonen verfügbar gemacht werden. Es gibt außerdem einen Server, der Anfragen der App verarbeitet und Nachrichten speichert.
    \begin{enumerate}
        \item Wie sollte man das erste Deployment der App gestalten?
        
        For the first deployment of the app, it is important to ensure that the app is stable and does not have any major bugs. It is also important to ensure that the app is easy to use and has a good user interface. One way to achieve this is to do a beta release of the app to a small group of users, and gather feedback from them before doing a full release. This way, any issues can be identified and fixed before the app is released to a larger audience.
        \item Eine neue Version der App ist fertig entwickelt. Lohnt sich ein Zero-Downtime-Release?
        
        Yes, a zero-downtime release would be beneficial for the app, especially if it is already being used by a large number of users. Given that the app is a real-time messaging app, it is important to minimize downtime as much as possible, as users may rely on the app for communication. A zero-downtime release would allow users to continue using the app without interruption while the new version is being deployed.
        

        \item Was sollte man bei diesem Release beachten?
        
        Apart from ensuring that it is a zero-downtime release, monitoring the app during and after the release is important to ensure that there are no issues. It is also important to have a rollback plan in case any issues arise during the release. Additionally, it is important to communicate with users about the release and any changes that may affect them.

        \item Wann sind Blue-Green Deployments sinnvoll?
        
        Blue-Green Deployments are useful when you want to minimize downtime and reduce the risk of deployment failures. This allows instant rollback to the previous version if any issues arise during the deployment. However, the hardware requirements for this type of deployment can be high, as it requires maintaining two separate environments (blue and green) or a single environment with enough resources to run both versions of the application simultaneously. Therefore, it may not be suitable for all projects, especially those with limited resources.
        \item Wann sind Canary Releases sinnvoll?
        
        Canary Releases are useful when you want to test a new version of the application with a small subset of users before rolling it out to the entire user base. This allows you to identify any issues or bugs in the new version before it affects all users. It is particularly beneficial for applications with a large user base, as it helps to minimize the impact of any potential issues that may arise during the deployment.

        \item Was passiert in unserer App während der Commit Stage?
        
        During the Commit Stage, the code changes are committed to the version control system (e.g., Git), and the CI/CD pipeline is triggered. This stage typically includes building the application, running unit tests, and performing static code analysis to ensure that the code meets quality standards. If any issues are found during this stage, the pipeline will fail, and the developers will need to address the issues before proceeding to the next stage.
        \item Was passiert in der Automated Acceptance Stage?
        
        During the Automated Acceptance Stage, automated tests are run to verify that the application meets the acceptance criteria defined for the release. This may include functional tests, integration tests, and end-to-end tests. The goal of this stage is to ensure that the application behaves as expected and that any new features or changes do not introduce regressions or break existing functionality.
        \item Was passiert in der manual Test Stage?
        
        During the Manual Test Stage, human testers manually test the application to identify any issues that may not have been caught by automated tests. This may include exploratory testing, usability testing, and user acceptance testing. The goal of this stage is to ensure that the application is user-friendly and meets the needs of the end-users.
        \item Was passiert in der Release Stage?
        
        During the Release Stage, the new version of the application is deployed to production. This may involve deploying to a staging environment first for final testing before deploying to production. The goal of this stage is to ensure that the deployment process goes smoothly and that any issues that arise during deployment can be quickly addressed.
        \item Würden Sie eher Continuous Deployment oder Continuous Delivery für das Projekt nutzen? Argumentieren Sie.
        
        For this project, I would recommend using Continuous Delivery. This is because Continuous Delivery allows for more control over the release process, as it requires a manual approval step before deploying to production. 
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}~
    \begin{enumerate}
        \item Warum lohnt es sich, Container in der Entwicklung und in der Deployment-Pipeline zu verwenden?
        
        Using containers in development and deployment pipelines can provide several benefits. Containers allow for consistent environments across different stages of the development and deployment process, which can help to reduce issues related to environment differences. They also allow for easier scaling and management of applications, as containers can be easily deployed and orchestrated using tools like Docker and Kubernetes. Additionally, containers can help to improve resource utilization, as multiple containers can run on a single host without the overhead of a full virtual machine.


        \item Welche Eigenschaften von \verb|cgroups| sind bei der Containerization nützlich?
        
        Control Groups (\verb|cgroups|) provide several useful features for containerization. They allow for resource allocation and limitation, which means that containers can be restricted in terms of CPU, memory, and other resources they can use. This helps to ensure that no single container can consume all the resources of the host system, which can lead to performance issues.
        \item In ihrer Ubuntu-VM sollten sie unter \verb|/sys/fs/cgroup/system.slice/docker.service| die Dateien finden die die ``docker.service''-\verb|cgroup| definieren. Schauen Sie sich \verb|cpu.max| und \verb|memory.max| an. Was sagen sie über diese \verb|cgroup| aus?
        
        In the Listing~\ref{lst:cgroup} you can see an example of the content of these files. In this case, the \verb|cgroup| is configured to use as much CPU and memory as needed, but it could be configured to use only a percentage of the CPU or a fixed amount of memory.
        \begin{listing}
            \begin{minted}[fontsize=\small]{bash}
$ cat /sys/fs/cgroup/system.slice/docker.service/cpu.max
max 100000
$ cat /sys/fs/cgroup/system.slice/docker.service/memory.max
max             
            \end{minted}
            \caption{Example of the content of the \texttt{cpu.max} and \texttt{memory.max} files of a \texttt{cgroup}.}
            \label{lst:cgroup}
        \end{listing}
        \item Welche Eigenschaften haben Namespaces, die bei der Containerisierung nützlich sind?
        
        Namespaces provide several useful features for containerization. They allow for isolation of resources, which means that each container can have its own view of the system resources, such as process IDs, network interfaces, and file systems. This helps to ensure that containers do not interfere with each other and can run independently. Additionally, namespaces can help to improve security, as they can limit the visibility of resources to only those that are necessary for the container to function.
        \item Welche Eigenschaften hat \verb|chroot| bzw. \texttt{pivot\_root}, die bei der Containerization nützlich ist, und was unterscheidet die beiden?
        
        Both \verb|chroot| and \texttt{pivot\_root} are used to change the root directory, but they have different use cases. \verb|chroot| changes the root directory for the current process and its children, while \texttt{pivot\_root} changes the root directory for the entire system. In containerization, \texttt{pivot\_root} is more commonly used, as it allows for a complete change of the root file system for the container, while \verb|chroot| is more limited in scope.
        \item Was unterscheidet Containerization von Virtual Machines?
        
        As already explained, containerization uses directly the host operating system's kernel, while virtual machines run a full guest operating system on top of a hypervisor. This means that containers are generally more lightweight and have lower overhead than virtual machines, as they do not require a full operating system to be running. Additionally, containers can be started and stopped more quickly than virtual machines, as they do not require the same level of initialization.
    \end{enumerate}
\end{ejercicio}