\section{Deployment}

\begin{ejercicio}
    Die \emph{Echtzeit-Messaging-App} für den Campus der  ``Universität der Zukunft'' soll bereitgestellt werden. Die App soll zunächst auf Android-Telefonen verfügbar gemacht werden. Es gibt außerdem einen Server, der Anfragen der App verarbeitet und Nachrichten speichert.
    \begin{enumerate}
        \item Wie sollte man das erste Deployment der App gestalten?
        \item Eine neue Version der App ist fertig entwickelt. Lohnt sich ein Zero-Downtime-Release?
        \item Was sollte man bei diesem Release beachten?
        \item Wann sind Blue-Green Deployments sinnvoll?
        \item Wann sind Canary Releases sinnvoll?
        \item Was passiert in unserer App während der Commit Stage?
        \item Was passiert in der Automated Acceptance Stage?
        \item Was passiert in der manual Test Stage?
        \item Was passiert in der Release Stage?
        \item Würden Sie eher Continuous Deployment oder Continuous Delivery für das Projekt nutzen? Argumentieren Sie.
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}~
    \begin{enumerate}
        \item Warum lohnt es sich, Container in der Entwicklung und in der Deployment-Pipeline zu verwenden?
        \item Welche Eigenschaften von cgroups sind bei der Containerization nützlich?
        \item In ihrer Ubuntu-VM sollten sie unter \verb|/sys/fs/cgroup/system.slice/docker.service| die Dateien finden die die ``docker.service''-\verb|cgroup| definieren. Schauen Sie sich \verb|cpu.max| und \verb|memory.max| an. Was sagen sie über diese \verb|cgroup| aus?
        \item Welche Eigenschaften haben Namespaces, die bei der Containerisierung nützlich sind?
        \item Welche Eigenschaften hat \verb|chroot| bzw. \verb|privot_root|, die bei der Containerization nützlich ist, und was unterscheidet die beiden?
        \item Was unterscheidet Containerization von Virtual Machines?
    \end{enumerate}
\end{ejercicio}