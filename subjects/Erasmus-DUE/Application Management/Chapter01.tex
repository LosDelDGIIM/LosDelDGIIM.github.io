\chapter{Application Lifecycle Management (ALM)}

\section{Application Lifecycle Management (ALM)}

Creating an Application is not just installing it and updating it, it should cover much more aspects throughout its whole lifecycle, from the initial idea to its end of life. With that in mind, we define the following.
\begin{definicion}[Application Lifecycle Management (ALM)]
    ALM is the framework that defines the process of managing an Application throughout its whole lifecycle, from the initial idea to its end of life. It integrates people, processes and tools to manage the Application effectively and efficiently.
\end{definicion}

This framework lets to manage the complexity of modern Applications. Nowadays there are a lot of different people involved in the creation and maintenance of an Application (Developers, Bussiness Analysts, Testers, Final Users, etc). ALM provides a structured approach to coordinate all these people and their tasks. This lets everyone to know \emph{what should they do at any moment}. This leads to overcome the typical ``controled chaos'' that usually happens in large projects.\\


The phases of the ALM are the following ones:
\begin{itemize}
    \item Design \& Development
    \item Continuous Integration
    \item Source Control \& Configuration Management
    \item Quality Assurance
    \item Requirement Management
\end{itemize}

% // TODO: Phases? Is one after the other?

Its main goals are the following ones:
\begin{itemize}
    \item Create fastly high-quality products.
    \item Definition of tasks, roles and responsibilities.
    \item Knowing which tasks are being done, by whom and when.
    \item It improves the communication between teams.
\end{itemize}

It takes into account one big problem: \emph{too much planning can have negative consequences}. If every single detail is planned, it can lead to a lack of flexibility and adaptability to changes. Therefore, when new changes are planned, they are usually not taken into account, leading to a worse final product.\\

In addition, the first, difficult step in ALM is to define the requirements of the Application. It should be taken into account that many organizations are in a hurry to develop and release the Application in order to be competitive in the market. With that in mind, a minimum set of requirements that gives them the competitve advantage should be defined. This firsy prototype should be developped and released as soon as possible. After that, new features can be added in future versions of the Application.

\section{Software Development Lifecycle (SDLC)}

The Software Development Lifecycle (SDLC) is a methodology that defines the process of creating and maintaining software applications. It is a structured approach that covers all the phases of the software development process, from the initial idea to its end of life. It defines some guidelines and best practices to reduce future problems. It also helps to decide the responsibilities of each team member, so that everyone knows what they should do at any moment.\\

It should not be confused with the following concepts:
\begin{description}
    \item[VS ALM]: SDLC is a part of ALM. While ALM covers the whole lifecycle of an Application, SDLC focuses on the development phase.
    \item[VS System Development Lifecycle]: System Development Lifecycle also takes into account testing and using softwares from third parties. It is really important to not blindly trust third-party softwares, as they can have security vulnerabilities or other problems that can affect the final product. There are ISO standards for Software and System Development Lifecycles.
\end{description}

The following subsections describe some concretes SDLC models. The number of phases of the SDLC can vary depending on the model used. Regarding documentation (which is usually not included into the phases), it often overlooked (functional software is more important than comprehensive documentation), but it should ideally be complete.

\subsection{Waterfall Model}

The Waterfall Model is a linear and sequential approach to software development. It is the one that has been historically used the most.
\begin{description}
    \item[Advantages]: It is easy to understand and manage. The phases do not overlap.
    \item[Disadvantages]: It is inflexible to changes. Once a phase is completed, it is difficult to go back to it. In addition, a working product is not available until the end of the process.
\end{description}

It should only be used when the requirements are well understood and unlikely to change during the development process. It is not suitable for complex or large projects where requirements may evolve over time.

\subsubsection{Phases}

\begin{enumerate}
    \item \ul{Requirements and Analysis} \emph{What should the System do?}
    
    A good requirements list is essential for the success of the project. Test cases should be defined at this stage to ensure that the final product meets the requirements. They should be \emph{relevant, valid and verifiable}. They are divided into Functional Requirements (what the system should do) and Non-Functional Requirements (how the system should be, e.g., performance, security, usability, etc).


    \item \ul{Design \& Architecture} \emph{How should the System be designed?} Online/Offline, etc.
    
    The system architecture is defined at this stage. It should let the requirements be implemented effectively and efficiently. One important aspect is the scalability of the system to a higher number of users or data.

    \item \ul{Implementation \& Coding} \emph{How is the System going to be coded?}
    
    The actual coding of the system is done at this stage. It should be taken into account that the knowledge of the different stakeholders can vary a lot.

    \item \ul{Testing \& Quality Assurance} \emph{Does the System meet the requirements?}
    
    Testing is so important that it should be done in parallel with the coding (Test-Driven Development and Continuous Integration). The final tests are usually done by a different team (QA Team) to ensure the objectivity of the tests. In really critical systems, formal verification techniques can be used to mathematically prove that the system meets its requirements.


    \item \ul{Deployment \& Maintenance} \emph{How do the deployment and updates work?}
    
    The system is deployed. Two aspects should be taken into account:
    \begin{itemize}
        \item Continuous Deployment: The changes in the code should be automatically considered. Automatic tests should be done to ensure that the new code does not introduce new bugs.
        \item Maintenance: A balance between new versions and bug fixing the current version should be found. Releasing new updates can be difficult depending on the type of Application.
    \end{itemize}
\end{enumerate}

\subsection{Agile Model}

\subsubsection{Scrum}

Scrum is an Agile iterative and incremental framework for managing software development projects. There are three main roles:
\begin{enumerate}
    \item Product Owner: Responsible for defining the product vision (client representative).
    \item Scrum Master: Responsible for ensuring that the Scrum process is followed.
    \item Development Team: Responsible for delivering the product increment.
\end{enumerate}

The development process is divided into Sprints (usually 2-4 weeks long). Each Sprint has 4 main events:
\begin{enumerate}
    \item Sprint Planning
    \item Daily Scrum
    \item Sprint Review
    \item Sprint Retrospective
\end{enumerate}

The main tools (artifacts) used in Scrum are:
\begin{itemize}
    \item Product Backlog: List of all desired work on the project.
    \item Sprint Backlog: List of tasks to be completed in the current Sprint.
    \item Increment: The sum of all the completed products.
\end{itemize}

\subsubsection{DevOps}

DevOps is a set of practices that combines software development (Dev) and IT operations (Ops). Its main goal is to shorten the development lifecycle and provide continuous delivery with high software quality. It emphasizes collaboration, communication, and integration between development and operations teams.

\subsubsection{Agile ALM}

The agile ALM is a flexible and iterative SDLC approach that focuses on delivering value to the customer through continuous feedback and improvement. It follows the principles of Agile development.
\begin{center}
    Individuals and interactions $\succ$ Processes and tools\\
    Working software $\succ$ Comprehensive documentation\\
    Customer collaboration $\succ$ Contract negotiation\\
    Responding to change $\succ$ Following a plan
\end{center}

The principles of Agile ALM are:
\begin{enumerate}
    \item Satisfy the customer through early and continuous delivery of valuable software.
    \item Welcome changing requirements, even late in development.
    \item Deliver working software frequently.
    \item Business people and developers must work together daily throughout the project.
    \item Build projects around motivated individuals.
    \item The most efficient method of conveying information is face-to-face conversation.
    \item Working software is the primary measure of progress.
    \item Agile processes promote sustainable development. Everyone should maintain a constant pace indefinitely.
    \item Continuous attention to technical excellence and good design enhances agility.
    \item Simplicity--the art of maximizing the amount of work not done--is essential.
    \item The best architectures, requirements, and designs emerge from self-organizing teams.
    \item At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.
\end{enumerate}

% // TODO: Should we learn the manifesto by heart?