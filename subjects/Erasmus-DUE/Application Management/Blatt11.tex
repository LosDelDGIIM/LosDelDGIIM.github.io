\section{Fuzzing \& Z3 2}

Zu den folgenden Aufgaben finden Sie \myhref{https://github.com/LosDelDGIIM/LosDelDGIIM.github.io/blob/main/subjects/Erasmus-DUE/Application\%20Management/Blatt_Material/blatt11_material.zip}{hier} ein \verb|zip|-Datei mit den notwendigen Ressourcen. Sie müssen auch ein paar Python-Pakete installieren, um die Aufgaben zu lösen.
\begin{enumerate}
    \item Öffnen Sie das Terminal (\verb|ctrl + Alt + T|)
    \item Installieren Sie den Package Installer for Python\\(\verb|$ sudo apt install python3-pip python3-venv|)
    \item Erstellen Sie ein neues Virtual Environment\\(\verb|$ python3 -m venv ./venv|)
    \item Konfigurieren Sie die aktuelle Shell, damit sie das \verb|venv| verwendet.\\(\verb|$ source ./venv/bin/activate|)
    \item Installieren Sie \verb|z3|\\(\verb|$ pip3 install z3-solver|)
    \item Atheris können Sie in einem Ubuntu 24.04 Container installieren\\(\verb|$ pip3 install atheris|)
\end{enumerate}

\begin{ejercicio}~
    \begin{enumerate}
        \item Nutzen Sie \verb|atheris| und instrumentieren Sie die \verb|validate|-Funktion in \verb|fuzz.py|.
        
        The new code should look like Listing~\ref{lst:atheris}.
        \begin{listing}
\begin{minted}[fontsize=\small]{python}
#!./venv/bin/python3

from typing import List
import atheris
import sys

# PASSCODE = [getrandombits(8) for _ in range(4)]
PASSCODE = [64, 63, 121, 119]


def validate(data: List[int]):
    if len(data) != 4:
        return

    if PASSCODE[0] == data[0]:
        if PASSCODE[1] == data[1]:
            if PASSCODE[2] == data[2]:
                if PASSCODE[3] == data[3]:
                    raise RuntimeError("passcode match")
    return


atheris.instrument_func(validate)
atheris.Setup(sys.argv, validate)
atheris.Fuzz()
            \end{minted}
            \caption{Fuzzing mit Atheris}
            \label{lst:atheris}
        \end{listing}
        \item Zeichnen Sie einen Kontrollflussgraphen für die Funktion. Nutzen Sie als Knotennamen die Zeilen-nummern.
        
        The control flow graph for the \verb|validate| function is shown in Figure~\ref{fig:cfg2}.
        \begin{figure}
            \centering
            \begin{tikzpicture}[
                    node distance=1cm,
                    block/.style={rectangle, draw, fill=blue!10, text width=3cm, align=center, rounded corners, minimum height=1cm},
                    pathConstraint/.style={rectangle, draw, fill=green!10, text width=3cm, align=center, rounded corners, minimum height=1cm},
                    decision/.style={diamond, draw, fill=yellow!10, aspect=3.5, text width=6cm, align=center, inner sep=0pt},
                    error/.style={rectangle, draw, fill=red!20, text width=3cm, align=center, rounded corners},
                    arrow/.style={thick, -{Stealth[scale=1.2]}}
                ]

                % Nodos
                \node (start) [block, text width=7cm] {11:\\\texttt{def validate(data: List[int])}};
                \node (if0) [decision, below= of start] {12:\\\texttt{len(data) != 4}};
                \node (if0F_if1) [decision, below= of if0] {15:\\\texttt{PASSCODE[0] == data[0]}};
                \node (if0F_if1T_if2) [decision, below= of if0F_if1] {16:\\\texttt{PASSCODE[1] == data[1]}};
                \node (if0F_if1T_if2T_if3) [decision, below= of if0F_if1T_if2] {17:\\\texttt{PASSCODE[2] == data[2]}};
                \node (if0F_if1T_if2T_if3T) [decision, below= of if0F_if1T_if2T_if3] {18:\\\texttt{PASSCODE[3] == data[3]}};
                \node (error) [error, below= of if0F_if1T_if2T_if3T] {19\\\textbf{RuntimeError:} passcode match};
                \node (return1) [block, left= of error, xshift=-2cm] {13\\\texttt{return}};
                \node (return2) [block, right= of error, xshift=2cm] {20\\\texttt{return}};

                % Flechas
                \draw [arrow] (start) -- (if0);
                \draw [arrow, color=red] (if0) -- node[anchor=east] {\color{red} F} (if0F_if1);
                \draw [arrow, color=green] (if0F_if1) -- node[anchor=east] {\color{green} T} (if0F_if1T_if2);
                \draw [arrow, color=green] (if0F_if1T_if2) -- node[anchor=east] {\color{green} T} (if0F_if1T_if2T_if3);
                \draw [arrow, color=green] (if0F_if1T_if2T_if3) -- node[anchor=east] {\color{green} T} (if0F_if1T_if2T_if3T);
                \draw [arrow, color=green] (if0F_if1T_if2T_if3T) -- node[anchor=east] {\color{green} T} (error);

                \draw [arrow, color=green] (if0) -| node[anchor=east] {\color{green} T} (return1);
                \draw [arrow, color=red] (if0F_if1) -| node[anchor=west] {\color{red} F} (return2);
                \draw [arrow, color=red] (if0F_if1T_if2) -| node[anchor=west] {\color{red} F} (return2);
                \draw [arrow, color=red] (if0F_if1T_if2T_if3) -| node[anchor=west] {\color{red} F} (return2);
                \draw [arrow, color=red] (if0F_if1T_if2T_if3T) -| node[anchor=west] {\color{red} F} (return2);
            \end{tikzpicture}
            \caption{Kontrollflussgraph für das \texttt{validate}-Programm}
            \label{fig:cfg2}
        \end{figure}

        \item Bestimmen Sie die prozentuale Coverage, wenn der Code mit \verb|[246,63,103,121]| aufgerufen wird. Markieren Sie außerdem die erreichten Knoten im Kontrollflussgraphen.
        
        There is a total of 9 nodes in the control flow graph, and the input \verb|[246,63,103,121]| will cover 4 of them (the nodes corresponding to lines 11, 12, 15 and 20).  Therefore, the percentage of coverage is $\nicefrac{4}{9} \approx 44.44\%$.
        \item Instrumentieren Sie die \verb|validate|-Funktion in \verb|fuzz2.py|
        
        The new code should look like Listing~\ref{lst:atheris2}.
        \begin{listing}
            \begin{minted}[fontsize=\small]{python}
#!./venv/bin/python3
from typing import List
import atheris
import sys

# PASSCODE = [getrandombits(8) for _ in range(4)]
PASSCODE = [64, 63, 121, 119]


def validate(data: List[int]):
    if len(data) != 4:
        return

    if PASSCODE[0] == data[0]:
        if PASSCODE[1] % 3 == data[1]:
            if PASSCODE[2] * 2 + 4 == data[2]:
                if PASSCODE[3] + PASSCODE[0] == data[3]:
                    raise RuntimeError("passcode match")
    return


atheris.instrument_func(validate)
atheris.Setup(sys.argv, validate)
atheris.Fuzz()
            \end{minted}
            \caption{Fuzzing mit Atheris (veränderte \texttt{validate}-Funktion)}
            \label{lst:atheris2}
        \end{listing}
        \item Suchen Sie mittels \verb|z3| nach einer Lösung für \verb|validate|.
        
        The solution for the \verb|validate| function is shown in Listing~\ref{lst:z3}. It should be noted that the code has been ``translated'' so that \verb|z3| can know the constraints that need to be satisfied.
        \begin{listing}
            \begin{minted}[fontsize=\small]{python}
#!./venv/bin/python3
from typing import List
import z3

# PASSCODE = [getrandombits(8) for _ in range(4)]
PASSCODE = [64, 63, 121, 119]

solver = z3.Solver()
data = [z3.Int(f"data_{i}") for i in range(4)]

solver.add(len(data) == 4)
solver.add(PASSCODE[0] == data[0])
solver.add(PASSCODE[1] % 3 == data[1])
solver.add(PASSCODE[2] * 2 + 4 == data[2])
solver.add(PASSCODE[3] + PASSCODE[0] == data[3])

if solver.check() == z3.sat:
    model = solver.model()
    solution = [model[data[i]].as_long() for i in range(4)]
    print("Solution found:", solution)
else:
    print("No solution found.")
            \end{minted}
            \caption{Lösungssuche mit Z3}
            \label{lst:z3}
        \end{listing}
    \end{enumerate}
\end{ejercicio}

\begin{ejercicio}
Manche Programmierer nutzen Bit-Tricks, um auf spezifische Hardware zu optimieren. Nutzen Sie \verb|z3|, um zu zeigen, dass die Tricks auf einem 64-Bit-System dasselbe Verhalten haben wie eine naive Implementierung.
    \begin{enumerate}
        \item Tauschen zweier Variablen mit \verb|XOR|
        
        The code for swapping two variables using XOR is shown in Listing~\ref{lst:xor}, while the output of the code is shown in Listing~\ref{lst:xor_output}.
        \begin{listing}
            \begin{minted}[fontsize=\small]{python}
#!./venv/bin/python3

import z3

x, y = z3.BitVecs('x y', 64)
x0, y0 = x, y

x = x ^ y
y = x ^ y
x = x ^ y

solver = z3.Solver()
solver.add(z3.Not(z3.And(x == y0, y == x0)))

if solver.check() == z3.sat:
    model = solver.model()
    print("Counterexample found:", model)
elif solver.check() == z3.unsat:
    print("No counterexample found, the property holds.")
else:
    print("Solver returned unknown result.")
            \end{minted}
            \caption{Tauschen zweier Variablen mit XOR}
            \label{lst:xor}
        \end{listing}
        \begin{listing}
            \begin{minted}[fontsize=\small]{shell}
$ ./test_xor.py 
No counterexample found, the property holds.
            \end{minted}
            \caption{Output des XOR-Codes}
            \label{lst:xor_output}
        \end{listing}

        
        \item Tauschen zweier Variablen mit Subtraktion und Addition
        
        The code for swapping two variables using subtraction and addition is shown in Listing~\ref{lst:add_sub}, while the output of the code is shown in Listing~\ref{lst:add_sub_output}.
        \begin{listing}
            \begin{minted}[fontsize=\small]{python}
#!./venv/bin/python3

import z3

x, y = z3.BitVecs('x y', 64)
x0, y0 = x, y

x = x - y
y = x + y
x = y - x

solver = z3.Solver()
solver.add(z3.Not(z3.And(x == y0, y == x0)))

if solver.check() == z3.sat:
    model = solver.model()
    print("Counterexample found:", model)
elif solver.check() == z3.unsat:
    print("No counterexample found, the property holds.")
else:
    print("Solver returned unknown result.")
            \end{minted}
            \caption{Tauschen zweier Variablen mit Subtraktion und Addition}
            \label{lst:add_sub}
        \end{listing}
        \begin{listing}
            \begin{minted}[fontsize=\small]{shell}
$ ./test_add_sub.py 
No counterexample found, the property holds.
            \end{minted}
            \caption{Output des Subtraktion-Addition-Codes}
            \label{lst:add_sub_output}
        \end{listing}
        \item Die Bitreihenfolge innerhalb eines Bytes umkehren
        
        The code for reversing the bit order within a byte is shown in Listing~\ref{lst:reverse_bits}, while the output of the code is shown in Listing~\ref{lst:reverse_bits_output}.
        \begin{listing}
            \begin{minted}[fontsize=\small]{python}
#!./venv/bin/python3

import z3

def reverse_naive(n):
    # Your loop implementation adapted for Z3 symbolic execution
    result = z3.BitVecVal(0, 64)
    for i in range(64):
        # Move result left and add the last bit of n
        result = (result << 1) | (n & 1)
        # Logical Shift Right (LShR) to bring the next bit to the front
        n = z3.LShR(n, 1)
    return result

def reverse_optimized(n):
    # Optimized divide and conquer bit-swap
    # 1. Swap adjacent 32-bit blocks
    n = (z3.LShR(n, 32) & 0x00000000FFFFFFFF) | ((n << 32) & 0xFFFFFFFF00000000)
    # 2. Swap adjacent 16-bit blocks
    n = (z3.LShR(n, 16) & 0x0000FFFF0000FFFF) | ((n << 16) & 0xFFFF0000FFFF0000)
    # 3. Swap adjacent 8-bit blocks (bytes)
    n = (z3.LShR(n, 8)  & 0x00FF00FF00FF00FF) | ((n << 8)  & 0xFF00FF00FF00FF00)
    # 4. Swap adjacent 4-bit blocks (nibbles)
    n = (z3.LShR(n, 4)  & 0x0F0F0F0F0F0F0F0F) | ((n << 4)  & 0xF0F0F0F0F0F0F0F0)
    # 5. Swap adjacent 2-bit blocks
    n = (z3.LShR(n, 2)  & 0x3333333333333333) | ((n << 2)  & 0xCCCCCCCCCCCCCCCC)
    # 6. Swap adjacent bits
    n = (z3.LShR(n, 1)  & 0x5555555555555555) | ((n << 1)  & 0xAAAAAAAAAAAAAAAA)
    return n

x = z3.BitVec('x', 64)
solver = z3.Solver()

solver.add(reverse_naive(x) != reverse_optimized(x))

if solver.check() == z3.unsat:
    print("No counterexample found, the property holds.")
elif solver.check() == z3.sat:
    print("Counterexample found:", solver.model())
else:
    print("Solver returned unknown result.")
            \end{minted}
            \caption{Tauschen zweier Variablen mit Subtraktion und Addition}
            \label{lst:reverse_bits}
        \end{listing}
        \begin{listing}
            \begin{minted}[fontsize=\small]{shell}
$ ./test_reverse_bits.py 
No counterexample found, the property holds.
            \end{minted}
            \caption{Output des Bit-Reverse-Codes}
            \label{lst:reverse_bits_output}
        \end{listing}
    \end{enumerate}
\end{ejercicio}


\begin{ejercicio}
Nutzen Sie \verb|z3|, um generische Sudokus zu lösen.
\begin{observacion}
    Sollten Sie nicht weiterkommen, kann eine Internetsuche weiterhelfen.
\end{observacion}

The code for solving generic Sudokus using \verb|Z3| is available \myhref{https://github.com/ppmx/sudoku-solver/tree/master}{in this repository}.
\end{ejercicio}

\begin{ejercicio}
Ein Freund von Ihnen behauptet, dass er sein eigenes sicheres Krypto-System entwickelt hat. Zum System gehören zwei Komponenten: eine asymmetrische und eine symmetrische Chiffre. Zeigen Sie, dass beide Verfahren nicht sicher sind.
\begin{enumerate}
    \item Asymetric Cryptography:
    
    First of all, in the Source Code~\ref{lst:asymetric} we can see the \verb|main| function of the asymetric cryptography system. First of all, we should find the value of \verb|p| and \verb|q|, which are the prime numbers used in the RSA algorithm. In order to do so,in the \verb|ExtraSecureRsa| class, we can see the code shown in Listing~\ref{lst:extra_secure_rsa}. Therefore, we use the Z3 code shown in Listing~\ref{lst:z3_rsa} to find the values of \verb|p| and \verb|q|. The output is shown in Listing~\ref{lst:z3_rsa_output}.
    \begin{listing}
        \begin{minted}[fontsize=\small]{python}
def main():
secret =  # hidden
rsa = ExtraSecureRsa(secret['p'], secret['q'])
plaintext =  # hidden
ciphertext = rsa.encrypt(plaintext)
assert ciphertext == 0x108fa52dfb76719... # In the .py file, the full value is shown
decrypted_plaintext = rsa.decrypt(ciphertext)
print(f'{plaintext}, {ciphertext:x}, {decrypted_plaintext}')
        \end{minted}
        \caption{Main function of the asymetric cryptography system}
        \label{lst:asymetric}
    \end{listing}
    \begin{listing}
        \begin{minted}[fontsize=\small]{python}
# verify that only my keypair can be used
w = 2596546088... # In the .py file, the full value is shown
x = p + 1328
y = p + 1329
z = q - 1
assert w*(x*z + y*z - x*y) == 4*x*y*z
        \end{minted}
        \caption{Code for finding the prime numbers used in the RSA algorithm}
        \label{lst:extra_secure_rsa}
    \end{listing}
    \begin{listing}
        \begin{minted}[fontsize=\small]{python}
        #!./venv/bin/python3
import z3

p, q = z3.Ints('p q')
w = 2596546088474... # In the .py file, the full value is shown
x = p + 1328
y = p + 1329
z = q - 1

s = z3.Solver()
s.add(w * (x*z + y*z - x*y) == 4*x*y*z)
s.add(p > 1, q > 1) # p & q should be positive (they are primes)

if s.check() == z3.sat:
m = s.model()
val_p = m[p]
val_q = m[q]

print(f"P: {val_p}\nQ: {val_q}")
else:
print("No solution found.")
        \end{minted}
        \caption{Z3 code for finding the prime numbers used in the RSA algorithm}
        \label{lst:z3_rsa}
    \end{listing}
    \begin{listing}
        \begin{minted}[fontsize=\small]{shell}
$ ./p_q_z3.py 
P: 129827304... # In the shell, the full value is shown
Q: 437651192... # In the shell, the full value is shown
        \end{minted}
        \caption{Output of the Z3 code for finding the prime numbers used in the RSA algorithm}
        \label{lst:z3_rsa_output}
    \end{listing}
    
    Once the values of \verb|p| and \verb|q| are found, and given that in the Listing~\ref{lst:asymetric} the value of \verb|ciphertext| is shown, we just decode it using the code shown in Listing~\ref{lst:decode_rsa}. The output is shown in Listing~\ref{lst:decode_rsa_output}.
    \begin{listing}
        \begin{minted}[fontsize=\small]{python}
def main():
    secret =  {
        'p': 12982730442... # The full value of p is used
        'q': 43765119208... # The full value of q is used
    }
    rsa = ExtraSecureRsa(secret['p'], secret['q'])
    ciphertext = 0x108fa52dfb76... # The full value of the ciphertext is used
    decrypted_plaintext = rsa.decrypt(ciphertext)
    print(f'Decrypted plaintext: {decrypted_plaintext}')
        \end{minted}
        \caption{Code for decoding the RSA ciphertext}
        \label{lst:decode_rsa}
    \end{listing}
    \begin{listing}
        \begin{minted}[fontsize=\small]{shell}
$ ./decode_rsa.py 
Decrypted plaintext: This is a not so secure rsa implementation.
        \end{minted}
        \caption{Output of the RSA decoding code}
        \label{lst:decode_rsa_output}
    \end{listing}




    \item Symmetric Cryptography:
    
    This one is more difficult to break. In order to break it, the code shown in Listing~\ref{lst:symmetric} is used to find the key used for the symmetric encryption. The output is shown in Listing~\ref{lst:symmetric_output}.
    \begin{listing}
        \begin{minted}[fontsize=\small]{python}
from z3 import *

# The captured ciphertext from the exercise
ciphertext = [7, 29, #... The full ciphertext is used here]

solver = Solver()

# 1. Define the Unknowns
key = [BitVec(f'key_{i}', 8) for i in range(4)]
plaintext = [BitVec(f'p_{i}', 8) for i in range(len(ciphertext))]

for i_block in range((len(ciphertext) + 3) // 4):
    for p in range(4):
        idx = i_block * 4 + p   # Real index in the ciphertext and plaintext arrays
        if idx < len(ciphertext):
            c_val = ciphertext[idx]
            k_val = key[p]
            p_val = plaintext[idx]
            
            solver.add(p_val == (c_val ^ k_val) - i_block)  # Use the decryption formula to relate plaintext, ciphertext, and key

            # 3. Apply Language Constraints
            solver.add(Or(
                And(p_val >= ord('a'), p_val <= ord('z')), # Lowercase
                And(p_val >= ord('A'), p_val <= ord('Z')), # Uppercase
                p_val == ord(' '),                         # Space
                p_val == ord('.'),                         # Period
                p_val == ord(',')                         # Comma
            ))

if solver.check() == sat:
    model = solver.model()
    decrypted_msg = "".join([chr(model[p].as_long()) for p in plaintext])
    discovered_key = "".join([chr(model[k].as_long()) for k in key])
    
    print("Success!")
    print(f"Secret Key: {discovered_key}")
    print(f"Hidden Message: {decrypted_msg}")
else:
    print("No legible solution found. Check the constraints or ciphertext.")
        \end{minted}
        \caption{Z3 code for breaking the symmetric cryptography system}
        \label{lst:symmetric}
    \end{listing}
    \begin{listing}
        \begin{minted}[fontsize=\small]{shell}
$ ./break_symmetric.py 
Success!
Secret Key: Sup3
Hidden Message: This is a not so secure encryption.
        \end{minted}
        \caption{Output of the Z3 code for breaking the symmetric cryptography system}
        \label{lst:symmetric_output}
    \end{listing}
\end{enumerate}
\end{ejercicio}