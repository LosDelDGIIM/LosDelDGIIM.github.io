\chapter{Clean Code}

We will focus on code, as we don't only want to write good code, but also tell the difference between good and bad code. However, we should firstly assume some claims:
\begin{itemize}
    \item \ul{There will always be code}
    
    In a system, there will always be requirements (as with no requirements, the system would not be needed). Code is simply a high specification of those requirements. In addition, given that we will have programming languages with high abstraction levels and that we will use AI, code will not disappear.

    \item \ul{Code is written for humans}
    
    Code is almost never just written once and then forgotten. We should always assume that code will be read by other people, and thus, we should write it in a way that is easy to understand.


    \item \ul{Bad code will bring your company down}
    
    If bad code is written, the cost of solving bugs will increase, and thus, the company will lose money. Code smells, which are indicators of bad code (they may not always be bugs), may include duplicated or commented code, long methods, or large classes.

    \item \ul{Start from the scratch will not fix the problem}
    
    When bad code becames so unmanageable, it may be tempting to start from scratch. However, this is not a good idea, as it will take a lot of time and resources, it may not solve the problem, and it may even lead to two systems developped in parallel, which will be a nightmare to maintain.

    In order to solve the problem, code should always be kept clean, following the \emph{Boyscout Rule}: ``Always leave the code cleaner than you found it''.
\end{itemize}

Once we have assumed these claims, we can start talking about clean code. Even though there is no single definition of clean code, it should just be as easy, minimal and \emph{simple} as possible. It should clearly express its intent. We will focus on some points that will help us to write clean code.


\section{Meaningful names}

We name a lot of components in our code, such as variables, functions, classes, etc. We should always try to give them meaningful names, as they will help us to understand the code.
\begin{enumerate}
    \item Use intention-revealing names.
    
    \texttt{int x;} is not a good name, as it does not reveal the intent of the variable.

    \item Avoid disinformation.
    
    We should not misuse known abbreviations, imply data types, or use similar names for different things.

    \item Make meaningful distinctions.
    
    We should not use the same name for different things, as it will be confusing. What is the difference between \texttt{a1} and \texttt{a2}? We should use names that clearly distinguish between different things.
    
    \item Avoid encodings
    
    Even though it was done in the past, type of scope information should not be encoded in the name, as it should nowadays be provided by the IDE.

    \item Regarding classes:
    
    Nouns should be used for classes, while verbs should be used for methods. Accessors (\texttt{getters}), mutators (\texttt{setters}), and predicates should be named accordingly, as they are very common and should be easily identifiable.

    \item Solution vs Problem Domain names
    
    Code that is related to the problem domain should be named accordingly, while code that is related to the solution domain should be named in a way that reflects its purpose.

    \item Use short, pronounceable names.
    
    A name should be as short as possible, as long as it provides enough context.
\end{enumerate}

Finding good names is not easy, but it is worth the effort, as it will make our code much easier to understand and maintain.

\section{Functions}\label{sec:functions}

Functions are one of the most important components of our code, as they are the building blocks of our programs. We should always try to write functions that are clean and easy to understand. Some guidelines for writing clean functions are:
\begin{enumerate}
    \item Small functions.
    
    Functions should be small (ideally, 3 lines or less), as they are easier to understand and maintain. If a function is too long, it may be a sign that it is doing too much and should be split into smaller functions.

    This may lead to a lot of functions, aspect that may be criticized and that may even impact performance. Therefore, each one should find the right balance between the number of functions and their size.

    \item Do one thing.
    
    A function should do one thing and do it well (Error handling is needed and is not considered as doing more than one thing). If the developper is tempted to write a comment before a block of code, it may be a sign that the function is doing too much and should be split into smaller functions.

    \item One Level of Abstraction per Function.
    
    A function should not mix different levels of abstraction. Each time a function is extracted, it should be at a lower level of abstraction than the one that calls it.

    \item Regarding arguments:
    \begin{enumerate}
        \item Low number of arguments.
        
        Functions should have a low number of arguments (ideally, 0 or 1), as they could be messed up when calling the function. If too many arguments are needed, maybe they should be encapsulated in an object.

        \item Output arguments should be avoided.
        
        It is assumed that arguments flow in the function, not out of it. 
        
        \item Flag arguments should be avoided.

    \end{enumerate}
        
        \item They should have no side effects.
        
        \item Command / Query Separation.
        
        Functions should either do something (command) or answer something (query), but not both. If a function does both, it may be a sign that it is doing too much and should be split into smaller functions.
        
        \item DRY (Don't Repeat Yourself).
        
        \item Exceptions should be used instead of return codes.
        
        \item Multiple \texttt{return} statements are acceptable.
        
        Functions should ideally follow a Strict-Structured Programming style, which means that they should have a single entry and a single exit point (only one \texttt{return} statement, no \texttt{break}, \texttt{continue}, or \texttt{goto} statements). However, in some cases, it may be acceptable to have multiple return statements, as long as they are used in a way that does not make the code harder to understand.
\end{enumerate}

\section{Comments}

Comments are a necessary evil. They are really extendedly used, but they are not always good. They may be outdated, they may be misleading, and they may even be used to explain bad code. Bad comments lead to people ignoring them, and thus, they may even hide important information.

The programmer should explain himself through the code, not through comments. Some bad examples are:
\begin{itemize}
    \item \texttt{int d; // elapsed time in days}
    \item Noise/Redundant Comments, as
    
    \texttt{int calculatePay() \{ // calculate the pay}
    \item Using a difficult condition and then explaining it with a comment, instead of just using a bool variable with a meaningful name or a function that encapsulated the condition.
    \item Comments that try to explain bad code, instead of just refactoring it to make it easier to understand.
    \item Mandatory comments, which are required by the company or by the project, but that do not provide any useful information.
    \item Non-Local information
    
    Comments should not provide information that is not local to the code they are commenting, as it may be easily forgotten and thus, lead to confusion.

    \item Comments of different sections of a function
    
    If a function is too long and it is divided into different sections, it may be a sign that the function is doing too much and should be split into smaller functions.

    \item Closing brace comments
    
    When a function is too long, it may be difficult to know which closing brace corresponds to which opening brace. However, if the function is too long, it should be split into smaller functions, and thus, closing brace comments should not be needed.

    \item Journal comments \& Attributions
    
    The VCS should be used to track changes and authorship, not comments.

    \item Commented-out code
    
    Again, the VCS should be used to track changes and to recover old code if needed, not comments.
    
\end{itemize}


However, there are some good comments, such as:
\begin{itemize}
    \item Legal comments, which are required by law or by the company.
    \item Explanation of intention
    
    Sometimes, a decision is made in a way that is not obvious, and it may be worth explaining the intention behind it. People may not agree with the decision, but at least they will understand it.

    \item Warning of consequences
    \item Amplification of a point in the code that is not obvious.
    
    People may not understand why a certain point in the code is important, and it may be worth amplifying it with a comment. If not done, another developper may change that point in the code, not understanding its importance, and thus, breaking the code.

    \item Comments to create Public API documentation (e.g., Javadoc).
\end{itemize}


Lastly, there are some comments that are not good, but that may be necessary, such as:
\begin{itemize}
    \item Clarification of a point in the code that is not obvious.
    
        Sometimes, a point in the code is not obvious, and it may be worth clarifying it with a comment. For instance, when a function returns a value that is not obvious, or when a complex regular expression is used, it may be worth clarifying it with a comment. However, it is risky because if the code is changed, the comment may become outdated and thus, misleading.
    
    \item TODO comments, which indicate that something needs to be done in the future.
    
    They may be used to ask a colleague to work on something, a reminder to change a part that depends on something else... but never to clean up bad code later.

    Modern IDEs have tools to track TODO comments, but they should be used with caution, as they may be forgotten and thus, lead to technical debt. The Boyscout Rule should be followed.
\end{itemize}
    
On conclusion, comments should be used with caution, as they may be outdated, misleading, and even hide important information. The code should explain itself, and if a comment is needed to explain a point in the code, it may be a sign that the code is not clean and should be refactored to make it easier to understand.