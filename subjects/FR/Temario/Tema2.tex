\chapter{Capa de red}

En el presente tema, estudiaremos a fondo la capa de red. Recordemos que seguimos el Modelo TCP/IP descrito en la Tabla~\ref{table:_tabla_de_capas}.
Esta capa es la capa de más bajo nivel que pertenece al \acrshort{NOS}, y será la primera estudiada en la asignatura.

\subsubsection{Objetivos}

\begin{itemize}
    \item Comprender las funcionalidades y servicios de la capa de red.
        \begin{itemize}
            \item Concepto de conmutación de paquetes y datagramas. 
            \item Direccionamiento en Internet.
            \item Encaminamiento salto a salto.
            \item Asociación con la capa de enlace a través del protocolo \acrshort{ARP}.
            \item Señalización de errores mediante el protocolo \acrshort{ICMP}.
        \end{itemize}
\end{itemize}

\section{Funcionalidades}

Funcionalidades y servicios TCP\@/IP\@:
\begin{itemize}
    \item \textbf{Direccionamiento:} identificación de equipos dentro de la red.
    \item \textbf{Encaminamiento:} llegar salto a salto desde el origen al destino. Especifica el camino que deben seguir los paquetes.
    \item \textbf{Fragmentación:} las tarjetas suelen tener un tamaño máximo de paquete, y si queremos enviar un paquete más grande tenemos que fragmentarlo y, en el destino, ensamblarlo. 
    \item \textbf{Conmutación.} 
    \item \textbf{Interconexión de redes.}
    \item En \acrshort{OSI}: \textbf{control de gestión.}
\end{itemize}

El protocolo que desarrollaremos en este tema es \acrshort{IP} por ser el que en la actualidad se ha impuesto, aunque existen otros como \acrshort{ATM}, x25\ldots

\section{Conmutación}

\begin{definicion}[Conmutación]
    Acción de establecer o determinar caminos de extremo a extremo que permitan transmitir información.         
\end{definicion}

Uno de los primeros ejemplos claros de conmutación que se vio en la tecnología de las comunicaciones fue la conmutación de circuitos para la telefonía, que desarrollamos a continuación.
\subsection{Conmutación de circuitos}

Antiguamente existía una conmutación física de circuitos, muy usada en telefonía. De esta forma, hay muchos cables entre los usuarios y las centrales (uno por cada usuario), y menos cables entre cada par de centrales, ya que no todos los usuarios hablan al mismo tiempo. \\

La comunicación por conmutación de circuitos implica tres fases:
\begin{enumerate}
    \item El establecimiento del circuito. Cada central une los cables que correspondan y se genera el camino. 
    \item La trasferencia de datos a través del circuito dedicado.
    \item La desconexión del circuito, se libera el circuito para su reutilización.
\end{enumerate}

\subsubsection{Beneficios}
\begin{itemize}
    \item Recursos dedicados (tenemos un cable solo para nosotros), lo que facilita las comunicaciones a tiempo real y sin retardos.
    \item El recurso se mantiene dedicado toda la sesión.
    \item No hay competición por conseguir el medio.
    \item El circuito es fijo, no hay decisiones de encaminamiento una vez establecido.
    \item Simplicidad en la gestión de los nodos intermedios.
\end{itemize}

\subsubsection{Desventajas}
\begin{itemize}
    \item Cuando un usuario no usa su cable no lo usa nadie más. Uso ineficiente de recursos.
    \item Hay establecimiento de llamada (para que todos los cables se toquen).
    \item Es poco tolerable a fallos, si algo no funciona, todo deja de funcionar.
\end{itemize}

\subsection{Conmutación de paquetes}
En la actualidad, no se envía una señal analógica; sino que, como sabemos, se envía el \acrshort{SDU} junto con la cabecera. El \acrshort{SDU} se ha de fragmentar en distintos bloques, a los que denominaremos \emph{paquetes} o \emph{fragmentos}. Por tanto, los paquetes son cada uno de los bloques del \acrshort{SDU} de la capa de red y, tras añadirle a cada uno su correspondiente cabecera, es lo que se envía como tal por la red.
\begin{observacion}
    En general, cuando se quiera hacer referencia a un conjunto de datos que se envía por la red, sin especificar en qué capa nos encontramos, o sin ser más precisos, también usaremos el término de \emph{paquete}.
\end{observacion}

A la hora de realizar la conmutación, hay dos formas de hacerlo, la conmutación mediante datagramas y la conmutación mediante circuitos virtuales.

\subsubsection{Conmutación de datagramas}\label{sec:conmutacion_de_datagramas}

Las características de la conmutación de datagramas son:
\begin{itemize}
    \item No hay establecimiento de conexión: enviamos un paquete y no sabemos si el otro extremo está encendido.
    \item El envío de los distintos paquetes se hace independientemente. El encaminamiento se hace paquete a paquete, por lo que se pueden seguir caminos distintos. Por este motivo, los paquetes pueden llegar desordenados, algo que controlarán otras capas.
    
    Además, si se produce fragmentación, no se ensamblarán los paquetes hasta que lleguen al destino, ya que distintos paquetes de un mismo datagrama pueden seguir distintos caminos. 
    \item En cada nodo intermedio los paquetes que llegan se almacenan en una cola, y cuando sea posible se envían al próximo nodo. 
    \item Como el encaminamiento se hace salto a salto, todos los paquetes han de tener la dirección de origen (para las respuestas o encaminamientos específicos, aunque esto no lo veremos en la asignatura) y de destino. A veces, para hacer difusiones de datos, nos puede interesar taner varias direcciones de destino.
\end{itemize}

Como el medio es común, los nodo de interconexión necesitan colas para poder gestionar los paquetes que le llegan.
A la hora de esta conmutación, se hace el mejor esfuerzo, pero si algo falla la capa de red no se encarga de gestionar el fallo.

Un protocolo que lleve a cabo esta conmutación es \acrshort{IP}, que desarrollaremos más adelante.
Este es el tipo de conmutación que se usa mayoritariamente en la actualidad, y es en la que nos centraremos en la asignatura.

\subsection{Conmutación con circuitos virtuales}

En este caso, la conmutación difiere ligeramente de la conmutación por datagramas vista, siendo una mezcla entre la conmutación de circuitos y la de paquetes.

En este caso, para enviar un paquete de un origen a un destino, aunque haya distintos caminos posibles, se establece el camino desde el principio denominado circuito (siguiendo la idea de la conmutación de circuitos). Este circuito no obstante es virtual, ya que los recursos no son dedicados completamente, sino que se reservan temporalmente pero se pueden reutilizar.

Cada router decide el camino que seguirá cada paquete, y los paquetes del mismo datagrama seguirán el mismo camino. Por tanto, el primer paquete en llegar al router reservará los recursos para los próximos paquetes.

\begin{itemize}
    \item Hay que establecer conexión para averiguar la ruta a seguir. 
    \item Si un router se cae, se cambia el camino. 
\end{itemize}

Un protocolo que lleva a cabo esta conmutación es \acrfull{ATM}, que estaba presente en el inicio de la telefonía digital.


\section{El protocolo \acrshort{IP}}

El \acrfull{IP} es un protocolo para la interconexión de redes.
Existen dos versiones:
\begin{itemize}
    \item \acrshort{IPv4}: Es la que se diseñó inicialmente, aunque tiene una limitación en la cantidad de direcciones.
    \item \acrshort{IPv6}: Pasó de 32 a 128 bits, lo que supone una cantidad en la práctica ilimitada de direcciones.
\end{itemize}
En la actualidad la limitación de direcciones se empieza a notar, por lo que hay una transición gradual hacia \acrshort{IPv6}, aunque sigue predominando \acrshort{IPv4}. Desorrallaremos \acrshort{IPv4} en este tema, aunque mencionaremos algunas diferencias con \acrshort{IPv6}.

\subsubsection{Características de \acrshort{IPv4}}
\begin{itemize}
    \item Resuelve el direccionamiento en Internet en la capa de red, ya que cada tarjeta de red tiene una dirección IP\@.
    \item Realiza el encaminamiento (o retransmisión) salto a salto entre equipos y routers.
    \item Ofrece un servicio no orientado a conexión y no fiable, ya que:
    \begin{itemize}
        \item No hay establecimiento de conexión lógica entre las entidades.
        \item No hay control de errores ni de flujos. Los errores que se produzcan tienen que arreglarlos una capa superior si se precisa.
    \end{itemize}
    \item Gestiona la fragmentación para adaptarse al \acrshort{MTU} de cada tarjeta de red, como veremos. A la unidad de datos completa se le llama datagrama y a los fragmentos paquetes. 
    \item Es un protocolo de máximo esfuerzo. Los datagramas se pueden perder, duplicar, retrasar, llegar desordenados\ldots
\end{itemize}

\subsection{Direccionamiento}

Para identificar cada equipo en la red, se usan direcciones IP\@. El lector posiblemente esté más familiarizado con las direcciones red, como \verb|www.google.com|, pero estas en realidad son nombres de dominio que se traducen a direcciones IP\@, como veremos en el Capítulo dedicado a la capa de aplicación. Mientras tanto, hemos de saber que todo equipo en la red tiene una dirección IP asociada. Además, esta (a priori) es única y no se puede repetir, lo que supone una limitación. Como más adelante veremos, para solventar este problema se usan también direcciones privadas, algo que no contemplaremos por el momento.\\

Una dirección \acrshort{IP} consta de 32 bits y la nomenclatura usada es: \verb|A.B.C.D| donde cada letra es un número decimal en el rango \verb|0-255| (ya que codificará 8 bits). El rango por tanto que tenemos es \verb|0.0.0.0-255.255.255.255.| Una dirección tiene dos partes bien diferenciadas, la que identifica la red y la que identifica el equipo en cuestión (en realidad, identifica la tarjeta de red).\\

Para saber qué parte de la dirección IP identifica el equipo y cuál la red, se emplea la máscara de red.
\begin{definicion}[Máscara de red]
    Es un conjunto de $32$ bits (al igual que una dirección IP) que se usa para identificar qué parte de la dirección IP identifica la red y cuál el equipo. Contiene los primeros $n$ bits consecutivos a $1$, y el resto a $0$.
\end{definicion}
\textbf{¿Cómo se usa la máscara?}\

Para saber cuál es la dirección de la red, se hace un \verb|AND| lógico entre la dirección IP y la máscara (por lo que nos quedaremos con los primeros $n$ bits de la dirección IP\@). El resto de bits identificará al equipo dentro de dicha red.\\

Notemos por tanto que, dentro de las posibles direcciones IP de una misma red, la dirección con todos los bits de equipo a 0 está \emph{reservada} para la dirección de la red, y no podrá asignarse a ningún equipo.
\begin{notacion}
    Es común querer dar una dirección IP junto a su máscara de red. Para esto, se podrá usar la notación \verb|A.B.C.D/n|, donde \verb|A.B.C.D| es la dirección IP en sí y \verb|n| es el número de bits a $1$ de la máscara de red. Como ya hemos mencionado que estos bits han de estar al inicio y consecutivos, sabiendo el valor de \verb|n| sabremos cuál es la máscara de red.
\end{notacion}

\begin{ejemplo}
    Supongamos que tenemos una dirección IP \verb|192.168.1.27/24|, y queremos saber cuál es la dirección de la red. Pasando a binario y haciendo un \verb|AND|, tenemos:
    \begin{equation*}
        \begin{array}{rcl}
            & 1100~0000~.~1010~1000~.~0000~0001~.~0001~1011 & \text{(dirección IP)}\\
            \texttt{AND} & 1111~1111~.~1111~1111~.~1111~1111~.~0000~0000 & \text{(máscara de red)}\\ \hline
            & 1100~0000~.~1010~1000~.~0000~0001~.~0000~0000 & \text{(dirección de la red)}
        \end{array}
    \end{equation*}
    Por tanto, pasando de nuevo a decimal, la dirección de la red es \verb|192.168.1.0|.
\end{ejemplo}

\subsubsection{Direccionamiento jeráriquico}
\noindent
Internet usa direccionamiento jerárquico basado en clases. Cada clase contiene las direcciones IP de un rango determinado:
\begin{itemize}
    \item Clase A $\rightarrow$ \verb|0xx|\ldots\verb|x/8| $\Longrightarrow $ \verb|0.0.0.0 - 127.255.255.255|. Tenemos $2^7~=~128$ redes con $2^{24} \approx 16\cdot 10^6$ equipos en cada una. 
    \item Clase B $\rightarrow$ \verb|10xx|\ldots\verb|x/16| $\Longrightarrow $ \verb|128.0.0.0 - 191.255.255.255|. Tenemos $2^{14}~=~16384$ redes con $2^{16}=65536$ equipos en cada una. 
    \item Clase C $\rightarrow$ \verb|110xx|\ldots\verb|x/24| $\Longrightarrow $ \verb|192.0.0.0 - 223.255.255.255|. Tenemos $2^{21}~\approx~2\cdot 10^6$ de redes con $2^{8} = 256$ equipos en cada una. 
    \item Clase D $\rightarrow$ \verb|1110xx|\ldots\verb|x| $\Longrightarrow$ \verb|224.0.0.0 - 239.255.255.255|. No se usa para identificar equipos ni redes sino para multidifusión (\textit{multicast}). Cada dirección identifica a todo un grupo de equipos. Para gestionar esto existe el protocolo \acrshort{IGMP} para suscribirse a grupos.
    \item Clase E $\rightarrow$ \verb|1111xx|\ldots\verb|x| $\Longrightarrow $ \verb|240.0.0.0 - 255.255.255.255|. Es el rango experimental; es decir, las direcciones que se dejan para hacer pruebas. 
\end{itemize}

\begin{observacion}
    Como utilidad, en los sistemas operativos Linux se ofrece el comando \verb|ipcalc|, que podrá ser de utilidad en los ejercicios prácticos. Dada una dirección IP y una máscara de red, nos devolverá la dirección de la red, la dirección de difusión, el rango de direcciones posibles, etc.
\end{observacion}
\begin{observacion}
    En Linux, podemos emplear el comando \verb|ifconfig| para ver la configuración de red de nuestro equipo. En la salida, veremos para cada una de las interfaces de red la dirección IP, la máscara de red, la dirección de difusión, etc.
\end{observacion}

\subsubsection{Direcciones reservadas}
Además de las restricciones de cada clase, hay determinadas direcciones que están reservadas y no se pueden asignar a ningún equipo. Algunas de estas direcciones son:
\begin{itemize}
    \item Dirección de red: Cualquier dirección IP con todos los bits de equipo a $0$. Está dedicada para identificar la red en sí.
    \item Dirección de difusión (\textit{broadcast}): Cualquier dirección IP con todos los bits de equipo a $1$. Se usa para enviar un paquete a todos los equipos de la red.
    
    Cuando se tiene que encontrar un equipo y no se sabe cuál, se manda por la dirección de difusión y lo escuchará quien tenga que escucharlo.

    \item \verb|127.a.b.c|: Denominada dirección de \textit{loopback}, \textit{localhost} o \textit{localloop}. Se usa para hacer pruebas, y es una conexión que hacemos a nuestra propia máquina. Originalmente (y la más común) era \verb|127.0.0.1|, pero en la actualidad se ha aumentado el rango.
    Estas redes no requieren de una tarjeta de red específica, y su interfaz de red se denomina \verb|lo|.
\end{itemize}

Llegados a este punto, podemos dar una definición más correcta de router, que ya habíamos mencionado anteriormente.
\begin{definicion}[Router]
    Es un dispositivo de la capa de red cuya funcionalidad principal es conectar distintas redes y encaminar los paquetes a través de ellas.
    
    Cuenta con varias tarjetas de red (también llamadas interfaces), una por cada red a la que se conecta, y cada una cuenta con una dirección IP asociada en cada red.\\

    Como curiosidad, es posible crear routers en un ordenador con varias tarjetas de red con \verb|Linux|. Con el comando \verb|sysctl -a| podemos consultar el valor de la variable \verb|net.ipv4.ip_forward|, que nos informa sobre si redirigimos paquetes o no. Si está con el valor $1$, dicho equipo es un router.
\end{definicion}

\begin{observacion}
    Como un switch funciona a nivel de enlace, todo lo conectado a dicho switch está en la misma red. Por tanto, tampoco tiene dirección IP asignada.
\end{observacion}

% // TODO: mencionar sobre dibujos de redes, switches, router domestico .. .

\subsubsection{Direccionamiento sin clases}

Si usamos solo el direccionamiento con clases estaríamos desperdiciando muchísimas direcciones IP. Por ejemplo, si tenemos 1000 equipos ($2^8<1000<2^{16}$) tendríamos que usar una red de clase B, con la que desperdiciaríamos más de 60.000 direcciones. La solución a este problema es usar el direccionamiento sin clase, que nos permite usar la máscara de red deseada.

\begin{itemize}
    \item \textbf{Subredes}\

    Si, por ejemplo, queremos una red de menos de 256 equipos, podemos aumentar el número de bits de la máscara a $1$, para conseguir más bits dedicados a identificar la red y menos para identicar equipos. Cada vez que añadimos un bit a la máscara, estamos dividiendo una red en dos mitades. 
    \begin{ejemplo}
        Supongamos que queremos identificar 100 equipos dentro de una misma red. Contando además con la dirección de red y la de difusión, necesitamos 102 direcciones. Como $2^6<102<2^7$, necesitamos 7 bits para identificar a los equipos. Por tanto, la máscara a usar será \verb|/25|.
    \end{ejemplo}
        \item \textbf{Superredes}\

            Si hacemos el procedimiento inverso, quitarle un bit a la máscara, duplicamos la cantidad de equipos que podemos direccionar. Por ejemplo, en \verb|/23| estamos juntando dos redes de clase C. 
    \begin{ejemplo}
        Supongamos que queremos una red de 1000 equipos. Contando con la dirección de red y la de difusión, necesitamos 1002 direcciones. Como $2^9<1002<2^{10}$, necesitamos 10 bits para identificar a los equipos. Por tanto, la máscara a usar será \verb|/22|.
    \end{ejemplo}
\end{itemize}


Como vemos el funcionamiento es igual que en el direccionamiento con clase, pero reduce significativamente (aunque no elimina) el desperdicio de direcciones. A nivel práctico red, subred y superred no se diferencian, y nos referimos a todas ellas como redes.

\subsubsection{Direcciones privadas}

Como hemos venido mencionando en distintas ocasiones, la escasez de direcciones es un gran problema presente en \acrshort{IPv4}, ya que tan solo hay $2^{32}$ direcciones posibles, las cuales ya se agotaron en Noviembre de 2019. Aunque se vayan recopilando direcciones de sitios obsoletos, empresas desaparecidas, etc. el problema sigue existiendo.\\

Hay varias soluciones posibles para solventarlo.
\begin{itemize}
    \item Direccionamiento sin clase: es una solucion que reduce el desperdicio de direcciones, pero aun así tiene la limitación de $2^{32}$ direcciones.
    \item \acrshort{IPv6}, el cual usa 128 bits para las direcciones. La notación utilizada es\

        \verb|FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF|, en el que cada dígito es un número hexadecimal.

    En total hay $2^{128}$ direcciones posibles (más de $10^{37}$), lo que en la práctica las hace ilimitadas. Aunque sea compatible con \acrshort{IPv4}, la transición está siendo lenta.
    \item Direcciones privadas: esta es la principal solución que se usa en la actualidad, ya que hace el número de direcciones prácticamente ilimitado. Desarrollaremos este concepto a continuación.
\end{itemize}

\begin{description}
    \item [Direcciones públicas:] Cada dirección se asigna a un único dispositivo en todo Internet. Se asignan centralizadamente\footnote{Inicialmente por \acrshort{IANA}, actualmente por \acrshort{ICANN}.}, y como son limitadas, hay que pagar por cada una.
    \item [Direcciones privadas:] Solo se pueden usar en redes privadas o \textit{intranets}, sin acceso directo al resto de Internet. Por tanto, al no ser accesibles desde fuera, se pueden repetir en distintas redes privadas, lo que aumenta el número de direcciones disponibles.
    
    Para poder comunicarse con el resto de Internet (ya que si no tendrían poca utilidad), será necesario una dirección pública por la cual se haga la comunicación. Para esto se usa el \acrshort{NAT}, que veremos más adelante.
\end{description}

Respecto al direccionamiento jerárquico con clases, dentro de cada clase se definen algunos rangos de direcciones a usar como IP privadas. Estos rangos son:
\begin{itemize}
    \item Clase A $\rightarrow$ \verb|10.x.y.z/8|
    \item Clase B $\rightarrow$ \verb|172.16-31.y.z/16|
    \item Clase C $\rightarrow$ \verb|192.168.y.z/24|
\end{itemize}



\subsection{\acrfull{NAT}}

Como hemos mencionado anteriormente, para que una red privada pueda comunicarse con el resto de Internet, es necesario que haya una dirección pública que haga de intermediario. Para esto se usa la técnica de \acrshort{NAT}, que posibilita la traducción de direcciones.
Al encontramos en la capa de red, el \acrshort{PDU} contiene la cabecera IP\footnote{En realidad, los puertos se encuentran en la cabecera de la capa de transporte; pero tras encapsularlo se puede acceder desde la capa de red.} que contiene, entre otros datos:
\begin{itemize}
    \item Dirección IP origen ({IPsrc}) junto con el puerto origen ({sport}).
    \item Dirección IP destino ({IPdest}) junto con el puerto destino ({dport}).
\end{itemize}

El concepto de puerto lo veremos más adelante y desarrollaremos a fondo en la Capa de Transporte. Por el momento, tan solo es necesario saber que es un número que se asigna a cada proceso que se comunica en la red, y que se usa para saber a qué proceso enviar la respuesta.\\

Para posibilitar la traducción, se usa una tabla de traducciones a modo de ``diccionario'', tal y como introducimos a continuación.
\begin{definicion}[Tabla de traducciones]
    La Tabla de Traducciones es una tabla que se guarda en la memoria de todo router que haga \acrshort{NAT}.
    Por cada traducción que deba hacerse, se guarda una entrada en la tabla que relaciona la dirección IP y puerto originales con la dirección IP y puerto traducidos.

    La tabla se va actualizando con cada nueva traducción, y cuenta con un temporizador (normalmente de 5 minutos) que borra las entradas que lleven un tiempo sin usarse. De esta forma, se evita que la tabla se sature y se libera memoria.

    En el caso de que llegue una petición que ya esté en la tabla, se reutiliza la información de la tabla, sin crearse una nueva entrada.
\end{definicion}

\begin{definicion}[\textit{Masquerading}]
    Proceso de enmascaramiento que hace el router al traducir la dirección privada del equipo en su dirección pública. Se ``enmascara'' la dirección privada, de forma que el servidor no sabe a qué equipo de la red privada está respondiendo.
\end{definicion}

\begin{observacion}
    El uso de \acrshort{NAT} plantea un problema de seguridad. Un atacante, conociendo la IP pública del router, puede hacer un barrido de puertos y puede conseguir que algún paquete entre. En tal caso, el router le responderá, y el atacante sabrá que hay un equipo detrás de esa IP pública y puerto, por lo que podrá intentar atacar a ese equipo.
    
    Para evitar esto, para cada traducción puede guardarse tanto las IP y puerto de origen y destino sin traducir, como las traducidas. De esta forma, si llega una petición que coincide con la IP y puerto origen, pero no con la IP y puerto destino, se descarta directamente. Esta técnica se denomina \textit{NAT estricto}.
\end{observacion}


Hay dos tipos de \acrshort{NAT}, en función de dónde y cuándo se haga la traducción.
\begin{description}
    \item [\acrfull{SNAT}:] el origen de los datos está en una red privada. Por tanto, al enviarse se cambia la dirección IP de origen, y la traducción a la correcta (en la respuesta) se hará tras el encaminamiento (\textit{postrouting}).
    \item [\acrfull{DNAT}:] el origen de los datos está en la red pública. Por tanto, al recibir los datos se cambia la dirección IP de destino, y la traducción a la correcta (en la respuesta) se hará antes del encaminamiento (\textit{prerouting}).
    
    En este caso la tabla de traducciones del router que realiza \acrshort{DNAT} ha de ser estática (la inserción debe ser a mano), ya que en otro caso el router no sabrá a donde redirigir las peticiones entrantes. Este proceso se denomina \textit{port forwarding}.
\end{description}


Planteemos un primer ejemplo de \acrshort{SNAT}, que nos ayudará a comprender cómo funciona esta técnica.
\begin{ejemplo}
    Supongamos la situación de la Figura~\ref{fig:ejemplo_nat}, en la que un portátil dentro de una red privada quiere acceder a un servidor HTTP en Internet.
    \begin{figure}
        \centering
        \begin{tikzpicture}[node distance=6cm]

            \node[laptop] (laptop) {};
            \node[below= 0 of laptop] {192.168.1.2/24};
            
            \node[router, right of=laptop] (router) {};
            %\node[below=0cm of router] {222.222.222.222/24};

            \node[cloud, right of=router, xshift=-3cm] (internet) {Internet};
    
            \node[server, right of=internet, xshift=-2cm] (server) {};
            \node[below=0cm of server] {66.66.66.66/24};
    
            \draw (laptop) -- (router) -- (internet) -- (server);
    
            % Conexiones del router
            \draw[fill] (router.west) circle [radius=0.1cm];
            \draw (router.west) -- ++(0,-1) node[below] {192.168.1.1/24};
            \draw[fill] (router.east) circle [radius=0.1cm];
            \draw (router.east) -- ++(0,1) node[above] {33.33.33.33/24};

            % 1: Petición del portátil al router
            \draw[-Stealth, dashed] ($(laptop.east) + (0.5,0.5)$) -- ($(router.west) + (-0.5,0.5)$) node[midway, above] {1};

            % 2: Petición del router a Internet
            \draw[-Stealth, dashed] ($(router.east) + (0.1,0.5)$) -- ($(internet.west) + (-0.1,0.5)$) node[midway, above] {};
            \draw[-Stealth, dashed] ($(internet.east) + (0.2,0.5)$) -- ($(server.west) + (-0.2,0.5)$) node[midway, above] {2};

            % 3: Respuesta del servidor al router
            \draw[-Stealth, dashed] ($(server.west) + (-0.2,-0.5)$) -- ($(internet.east) + (0.2,-0.5)$) node[midway, below] {3};
            \draw[-Stealth, dashed] ($(internet.west) + (-0.1,-0.5)$) -- ($(router.east) + (0.1,-0.5)$) node[midway, below] {};

            % 4: Respuesta del router al portátil
            \draw[-Stealth, dashed] ($(router.west) + (-0.5,-0.5)$) -- ($(laptop.east) + (0.5,-0.5)$) node[midway, below] {4};
        
        \end{tikzpicture}
        \caption{Ejemplo de red con \acrshort{SNAT}.}
        \label{fig:ejemplo_nat}
    \end{figure}

    El equipo envía una petición al router (1), que este reenvía al servidor (2). El servidor responde al router (3), que a su vez reenvía la respuesta al equipo (4). Se trata de \acrshort{SNAT}, ya que la petición parte de una red privada. Veamos qué ocurre en cada uno de los pasos:
    \begin{enumerate}[label=(\arabic*)]
        \item El ordenador envía una petición \acrshort{HTTP} al router.
        
        El puerto de origen, el cual asignará alteatoriamente el SO (ya se verá), pongamos que es el 1075. El puerto de destino, en el caso de \acrshort{HTTP}, es el 80. Por tanto, la cabecera IP del paquete que envía el portátil al router contendrá:
        \begin{itemize}
            \item {IPsrc}:{sport}: \verb|192.168.1.2:1075|.
            \item {IPdest}:{dport}: \verb|66.66.66.66:80|.
        \end{itemize}
            
        \item El router ha de realizar la traducción de direcciones, ya que la IP del portátil es privada y no puede ser usada en Internet. Para esto, modifica la cabecera IP poniendo como IP origen su propia IP pública, y como puerto origen un puerto que aún no haya sido usado (por ejemplo, 12345). La cabecera IP así:
        \begin{itemize}
            \item {IPsrc}:{sport}: \verb|33.33.33.33:12345|.
            \item {IPdest}:{dport}: \verb|66.66.66.66:80|.
        \end{itemize}

        La tabla de traducciones del router quedaría (donde notamos con ``$'$'' la traducida):
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c||c|c|}
                \hline
                IPsrc & sport & IPsrc$'$ & sport$'$ \\
                \hline
                \verb|192.168.1.2| & \verb|1075| & \verb|33.33.33.33| & \verb|12345|\\
                \hline
            \end{tabular}
            \caption{Tabla de traducciones del router con SNAT.}
            \label{tab:tabla_traducciones}            
        \end{table}

        Tras esta traducción, el router envía el paquete al servidor.
        
        \item Tras el procesamiento del paquete en el servidor, este envía la respuesta al router. La cabecera IP del paquete de respuesta contendrá:
            \begin{itemize}
                \item {IPsrc}:{sport}: \verb|66.66.66.66:80|.
                \item {IPdest}:{dport}: \verb|33.33.33.33:12345|.
            \end{itemize}
        
        \item El paquete llega sin problema al router, ya que la IP de destino es pública. El router debe realizar de nuevo la traducción para saber a qué equipo de la red privada debe enviar la respuesta. Para ello, consulta la tabla de traducciones (Tabla~\ref{tab:tabla_traducciones}) y, tras modificar de nuevo la cabecera IP (\textit{postrouting}), esta queda:
            \begin{itemize}
                \item {IPsrc}:{sport}: \verb|66.66.66.66:80|.
                \item {IPdest}:{dport}: \verb|192.168.1.2:1075|.
            \end{itemize}
    \end{enumerate}
\end{ejemplo}


Planteamos ahora el siguiente ejemplo de \acrshort{DNAT}, que nos ayudará ahora a comprender cómo funciona esta técnica.
\begin{ejemplo}
    Supongamos la situación de la Figura~\ref{fig:ejemplo_dnat}, en la que un portátil dentro de una red privada quiere acceder a un servidor HTTP en Internet.
    \begin{figure}
        \centering
        \begin{tikzpicture}[node distance=6cm]

            \node[server] (server) {};
            \node[below= 0 of server] {192.168.1.2/24};
            
            \node[router, right of=server] (router) {};
            %\node[below=0cm of router] {222.222.222.222/24};

            \node[cloud, right of=router, xshift=-3cm] (internet) {Internet};
    
            \node[laptop, right of=internet, xshift=-2cm] (laptop) {};
            \node[below=0cm of laptop] {66.66.66.66/24};
    
            \draw (server) -- (router) -- (internet) -- (laptop);
    
            % Conexiones del router
            \draw[fill] (router.west) circle [radius=0.1cm];
            \draw (router.west) -- ++(0,-1) node[below] {192.168.1.1/24};
            \draw[fill] (router.east) circle [radius=0.1cm];
            \draw (router.east) -- ++(0,1) node[above] {33.33.33.33/24};

            % 1: Petición del laptop al router
            \draw[-Stealth, dashed] ($(laptop.west) + (-0.2,0.5)$) -- ($(internet.east) + (0.2,0.5)$) node[midway, above] {1};
            \draw[-Stealth, dashed] ($(internet.west) + (-0.1,0.5)$) -- ($(router.east) + (0.1,0.5)$) node[midway, above] {};

            % 2: Petición del router a Internet
            \draw[-Stealth, dashed] ($(router.west) + (-0.5,0.5)$) -- ($(server.east) + (0.5,0.5)$) node[midway, above] {2};

            % 3: Respuesta del sever al router
            \draw[-Stealth, dashed] ($(server.east) + (0.5,-0.5)$) -- ($(router.west) + (-0.5,-0.5)$) node[midway, below] {3};

            % 4: Respuesta del router al laptop
            \draw[-Stealth, dashed] ($(router.east) + (0.1,-0.5)$) -- ($(internet.west) + (-0.1,-0.5)$) node[midway, below] {};
            \draw[-Stealth, dashed] ($(internet.east) + (0.2,-0.5)$) -- ($(laptop.west) + (-0.2,-0.5)$) node[midway, below] {4};        
        \end{tikzpicture}
        \caption{Ejemplo de red con \acrshort{DNAT}.}
        \label{fig:ejemplo_dnat}
    \end{figure}

    El equipo envía una petición al router (1), que este reenvía al servidor (2). El servidor responde al router (3), que a su vez reenvía la respuesta al equipo (4). Se trata de \acrshort{DNAT}, ya que la petición parte de la red pública. Veamos qué ocurre en cada uno de los pasos:
    \begin{enumerate}[label=(\arabic*)]
        \item El ordenador envía una petición \acrshort{HTTP} al router.
        
        El puerto de origen pongamos que es el 1050. El puerto de destino, tras la traducción efectivamente ha de ser el 80 (ya que es un servidor \acrshort{HTTP}). No obstante, antes de la traducción este puerto ha de ser el correspondiente al puerto que hayamos asignado al servidor \acrshort{HTTP} al que queremos acceder. Por ejemplo, sea la tabla de traducciones del router la de la Tabla~\ref{tab:tabla_traducciones_DNAT} (que hemos de haber configurado previamente en el \textit{port forwarding}).
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c||c|c|}
                \hline
                IPdest & dport & IPdest$'$ & dport$'$ \\
                \hline
                \verb|33.33.33.33| & \verb|23456| & \verb|192.168.1.2| & \verb|80|\\
                \hline
            \end{tabular}
            \caption{Tabla de traducciones del router con \acrshort{DNAT}.}
            \label{tab:tabla_traducciones_DNAT}
        \end{table}

        En tal caso, el puerto de destino será el 23456. Por tanto, la cabecera IP del paquete que envía el portátil al router contendrá:
            \begin{itemize}
                \item {IPsrc}:{sport}: \verb|66.66.66.66:1050|.
                \item {IPdest}:{dport}: \verb|33.33.33.33:23456|.
            \end{itemize}
        Notemos que la IP de destino no es el servidor como tal, sino el router (ya que es es al que tiene acceso el portátil), y el puerto de destino es el que hemos asignado en la tabla de traducciones para el servidor \acrshort{HTTP} al que queremos acceder.
            
        \item Tras llegar al router, este ha de realizar la traducción de direcciones (\textit{prerouting}), ya que la IP de destino era el router mismo. Consultando la tabla de traducciones (Tabla~\ref{tab:tabla_traducciones_DNAT}), la cabecera IP del paquete que envía el router al servidor quedará:
            \begin{itemize}
                \item {IPsrc}:{sport}: \verb|66.66.66.66:1050|.
                \item {IPdest}:{dport}: \verb|192.168.1.2:80|.
            \end{itemize}

        Tras esta traducción, el router envía el paquete al servidor (ya en la red privada).
        
        \item Tras el procesamiento del paquete en el servidor, este envía la respuesta al router. La cabecera IP del paquete de respuesta contendrá:
            \begin{itemize}
                \item {IPsrc}:{sport}: \verb|192.168.1.2:80|.
                \item {IPdest}:{dport}: \verb|66.66.66.66:1050|.
            \end{itemize}
        
        \item El paquete llega sin problema al router, ya que la IP de destino es pública. El router debe realizar de nuevo la traducción para saber ahora de qué equipo de la red privada proviene la petición. Para ello, consulta de nuevo la tabla de traducciones (Tabla~\ref{tab:tabla_traducciones}) y, tras modificar de nuevo la cabecera IP, esta queda:
            \begin{itemize}
                \item {IPsrc}:{sport}: \verb|33.33.33.33:23456|.
                \item {IPdest}:{dport}: \verb|66.66.66.66:1050|.
            \end{itemize}
    \end{enumerate}

    Notemos que, en el \acrshort{SNAT}, la tabla de traducciones se va actualizando con cada nueva traducción, mientras que en el \acrshort{DNAT} la tabla de traducciones ha de ser estática, ya que en otro caso el router no sabrá a donde redirigir las peticiones entrantes.
\end{ejemplo}

\subsection{Encaminamiento}
Se dice del proceso de encontrar el mejor camino para llevar la información (paquetes) de un origen a un destino dado. Como se vió en la Sección~\ref{sec:conmutacion_de_datagramas}, este se realiza salto a salto y paquete a paquete en función de la dirección IP destino del paquete y de las tablas de encaminamiento que hay en cada uno de los routers.

\subsubsection{Tablas de encaminamiento}

Las tablas de encaminamiento son tablas que se guardan en la memoria de todo equipo conectado a la red (tanto hosts como routers), que informan sobre las redes a las que se puede llegar y la mejor forma de llegar a ellas.\\

Veamos los campos que tienen estas tablas, donde notaremos entre paréntesis aquellos que tienen menor relevancia y que incluso no son siempre necesarios.
\begin{itemize}
    \item Red destino: Red a la que pertenecerá la dirección IP de destino, y a la cual queremos llegar.
    \item Máscara de red: Máscara de red correspondiente a dicha red de destino.
    \item Siguiente salto: Nodo al que debemos reenviar el paquete para que llegue a la red de destino.
    \item (Interfaz de salida del equipo), dato que puede ser redundante. 
    \item (Protocolo).
    \item (Flags).
    \item (Coste): Coste esperado para llegar a dicha dirección IP de destino. Este se puede medir, por ejemplo, mediante el número de saltos que se han de realizar.
\end{itemize}

Hay distintos tipos de rutas que se pueden almacenar en una tabla de encaminamiento:
\begin{description}
    \item [Rutas directas:] (marcadas con $\ast$ en el campo de ``Siguiente salto''). Estas son las redes a las que tenemos conexión directa, sin realizar ningún salto. Podemos enviar directamente el paquete al destinatario sin necesidad de pasar por nodos intermedios.
    
    Un router tiene acceso directo a las redes que interconecta (por lo que tendrá una entrada de este tipo por cada red), mientras que un host suele estar en una única red (por lo que tan solo tendrá una entrada de este tipo).

    En la mayoría de los casos, cuando se asigna una dirección IP a determinada tarjeta de red de un equipo, se almacena la entrada de esta ruta directa de forma automática.
    \item [Rutas indirectas:] Estas son las redes a las que no tenemos conexión directa, pero sí a través de un intermediario. Por tanto, es necesario dar mínimo un salto para llegar al destino.
     
    \item [Entrada por defecto:] (notado por \verb|0.0.0.0| o \verb|default| en red destino y \verb|/0| en máscara). Hace referencia a cualquier red que no haya sido aceptada por el resto de entradas. El equipo que se encuentra en el campo de ``Siguiente salto'' será el que nos conexta con el exterior, y lo denominaremos \emph{pasarela} o \textit{gateway}.
    
    Esta entrada no siempre es necesaria, aunque permite que no se produzcan errores (puesto que siempre habrá, al menos, una entrada válida para cada dirección IP, como más adelante veremos).
    
    \begin{comment}
    Además, poner simplemente un \verb|\0| en máscara es equivalente a una entrada por defecto (algo que veremos cuando entendamos el uso de estas tablas).
    \end{comment}

    \item [Entrada de \texttt{localhost}:] En el caso de que queramos usar esta técnica, también debe haber una entrada en la tabla de encaminamiento con este fin. Su red de destino será \verb|localhost|, y su interfaz, como mencionamos anteriormente, será \verb|lo|.
\end{description}

\noindent
Tenemos dos tipos de encaminamientos:
\begin{description}
    \item [Estático:] La tabla de encaminamiento se rellena a mano.
    \item [Dinámico:] La tabla de encaminamiento se rellena de forma automática, ya que hay un protocolo (\acrshort{RIP}, \acrshort{OSPF}\ldots) que se encarga de actualizarla. Tiene como ventaja que es dinámica (puede cambiar), ya que si se cae cierto router se puede buscar otro camino para llegar al destino.
\end{description}

\begin{observacion}
    En casos muy específicos (menos del $0.1\%$), se puede encaminar en función de la dirección IP origen, pero este caso no se desarrollará en la asignatura.
\end{observacion}

\begin{observacion}
    Como curiosidad, para consultar la tabla de encaminamiento de un equipo con \verb|Linux| se puede emplear el comando \verb|route -n|.
\end{observacion}

\subsubsection{Uso de la tabla de encaminamiento}

En esta sección entenderemos cómo funcionan estas tablas. Dada una dirección IP de destino, buscamos saber cuál es la dirección IP del nodo al que debemos enviarle el paquete para que este, finalmente, llegue al destino.\\

Para esto, buscamos las redes de destino de la tabla de encaminamiento que admitan a la dirección IP de destino. Para ello, se hace la operación lógica \verb|AND| entre la dirección IP de destino y la máscara de cada entrada, y si el resultado coincide con la red de destino entonces dicha entrada es válida para dicha IP\@.
\begin{itemize}
    \item Si no hay ninguna entrada válida, se envía un mensaje de error \acrshort{ICMP}, pero no se intenta solventar dicho error.
    \item Si hay más de una entrada válida, se escogerá aquella con la máscara de red más restrictiva, ya que la red de destino será más pequeña, teniendo así (a priori) una conexión más directa. Esto lo veremos en detalle en el próximo ejemplo.
\end{itemize}

Por tanto, una vez que tenemos la entrada asignada a la dirección IP de destino, se envía el paquete a la dirección IP del siguiente salto, continuando así el encaminamiento hasta llegar al destino.

\begin{ejemplo}\label{ejemplo:tabla_encaminamiento}
    Veamos un ejemplo de encaminamiento. Supongamos que estamos en la situación de la Figura~\ref{fig:ejemplo_tabla_encaminamiento}, y que la tabla de encaminamiento de R6 es la que se muestra en la Tabla~\ref{tab:encaminamientoR6} (donde hemos notado por \verb|IP_Exterior| a la IP del siguiente router que nos conecta con Internet).
    \begin{figure}
        \centering
        \resizebox{1\textwidth}{!}{
        \begin{tikzpicture}[node distance=3cm]

            \node[laptop] (l1) {};
            \node[laptop, right of=l1] (l2) {};
            \node[laptop, right of=l2] (l3) {};
            \node[laptop, right of=l3] (l4) {};
            \node[laptop, right of=l4] (l5) {};
            \node[laptop, right of=l5] (l6) {};
            \node[router, below of=l1, xshift=1.5cm] (r1) {};
            \node[router, below of=l3, xshift=1.5cm] (r2) {};
            \node[router, below of=l5, xshift=1.5cm] (r3) {};
            \node[router, below of=r1, xshift=3cm, yshift=1cm] (r4) {};
            \node[router, below of=r3, xshift=-3cm, yshift=1cm] (r5) {};
            \node[router, below of=r4, xshift=3cm, yshift=1cm] (r6) {};

            % Bucle for para marcar los routers
            \foreach \i in {1,...,6} {
                \node[yshift=-0.8em] at (r\i) {\color{white} \textbf{R\i}};
            }
            % Bucle for para marcar los laptops
            \foreach \i in {1,...,6} {
                \node[xshift=0.7em, yshift=0.7em] at (l\i) {\color{white} \textbf{L\i}};
            }

            \node[cloud, right of=r6] (cloud) {Internet};


            % Conexiones
            \draw[red] (l1.south) |- ($(r1.north) + (0,0.5)$) -| (l2.south);
            \draw[red] ($(r1.north) + (0,0.5)$) -- (r1.north);
            \draw (l3.south) |- ($(r2.north) + (0,0.5)$) -| (l4.south);
            \draw ($(r2.north) + (0,0.5)$) -- (r2.north);
            \draw (l5.south) |- ($(r3.north) + (0,0.5)$) -| (l6.south);
            \draw ($(r3.north) + (0,0.5)$) -- (r3.north);

            \draw[olive] (r1.east) -- (r2.west);
            \draw[olive] ($(r4.north) + (0,1.1)$) -- (r4.north);
            \draw (r2.east) -- (r3.west);
            \draw ($(r5.north) + (0,1.1)$) -- (r5.north);
            \draw[blue] (r4.east) -- (r5.west);
            \draw[blue] ($(r6.north) + (0,1.1)$) -- (r6.north);

            \draw (r6.east) -- (cloud.west);

            % Conexiones adicionales
            \draw[red] ($(l1.south) - (0,0.65)$) |- ($(r6.south) - (0,0.5)$) -- (r6.south);
            \draw[olive] ($(r1.east) + (0.5,0)$) |- (r6.west);

            % Conexiones del router r1
            %\draw[fill, red] (r1.north) circle [radius=0.1cm];
            %\draw[red] (r1.north) -- ++(0.5,0) node[right] {192.168.0.1/27};
            %\draw[fill, olive] (r1.east) circle [radius=0.1cm];
            %\draw[olive] (r1.east) |- ($(r1.south) +(0,0)$) -- ($(r1.south) +(0,-0.2)$) node[below] {192.168.0.1/24};

            % Conexiones del router r4
            %\draw[fill, olive] (r4.north) circle [radius=0.1cm];
            %\draw[olive] (r4.north) -- ++(0.5,0) node[right] {192.168.0.2/24};
            %\draw[fill, blue] (r4.east) circle [radius=0.1cm];
            %\draw[blue] (r4.east) |- ($(r4.east) +(0,0.4)$) -- ($(r4.east) +(0.2,0.4)$) node[right] {192.168.0.1/16};

            % Conexiones del router r6
            %\draw[fill, blue] (r6.north) circle [radius=0.1cm];
            %\draw[blue] (r6.north) -- ++(0.5,0) node[right] {192.168.0.2/16};
            %\draw[fill, olive] (r6.west) circle [radius=0.1cm];
            %\draw[olive] (r6.west) |- ($(r6.west) +(0,-0.2)$) -- ($(r6.west) +(-0.2,-0.2)$) node[left] {192.168.0.3/24};
            %\draw[fill, red] (r6.south) circle [radius=0.1cm];
            %\draw[red] (r6.south) -- ($(r6.south) +(0.5,0)$) node[right] {192.168.0.3/27};

            % Conexiones del L1
            \draw[red] (l1.north) node[above] {192.168.0.2/27};

            % Redes
            \node[red, above] at ($(r1.north) + (0,0.5)$) {192.168.0.0/27};
            \node[olive, above] at ($(r4.north) + (0,1.1)$) {192.168.0.0/24};
            \node[blue, above] at ($(r6.north) + (0,1.1)$) {192.168.0.0/16};
        \end{tikzpicture}}
        \caption{Situación para el ejemplo de la página~\pageref{ejemplo:tabla_encaminamiento}.}
        \label{fig:ejemplo_tabla_encaminamiento}
    \end{figure}

    \begin{table}
        \centering
        \begin{tabular}{|c|c|c|c|}
            \hline
            {Red de Destino} & {Máscara} & {Siguiente Salto} & {Interfaz}\\ \hline
            192.168.0.0 & {\color{red}/27} & $*$ & {\color{red}-}\\
            192.168.0.0 & {\color{olive}/24} & $*$ & {\color{olive}-}\\
            192.168.0.0 & {\color{blue}/16} & $*$ & {\color{blue}-}\\
            \verb|default| & {/0} & \verb|IP_Exterior| & -\\
            \hline
        \end{tabular}
        \caption{Tabla de encaminamiento de R6 para la Figura~\ref{fig:ejemplo_tabla_encaminamiento}.}
        \label{tab:encaminamientoR6}
    \end{table}

    Supongamos que a R6 le llega un paquete con destino L1 (dirección IP de destino \verb|192.168.0.1|). Tras hacer el \verb|AND| con cada una de las máscaras, vemos que las 4 entradas son válidas para dicha dirección IP\@. No obstante, la máscara más restrictiva es \verb|/27|, por lo que se elegirá dicha entrada y, por tanto, reenviará el paquete por la interfaz de red de R6 que pertenece a dicha red de destino. Esto permite que el camino se haga directo, con menos saltos.
\end{ejemplo}

En la mayoría de los casos, se buscará minimizar las tablas de encaminamiento agrupando las redes con las que se trabaja, permitiendo así que el encaminamiento sea más eficiente. Como mínimo tendremos una entrada por cada interfaz del dispositivo. Además, a menudo tenemos que compartir las tablas de encaminamiento (como veremos en algunos de los siguientes protocolos), y para ello lo mejor es que sean lo más compactas posible.

\subsection{Protocolos de intercambio de información de encaminamiento}

Para facilitar la administración y aumentar la escalabilidad, Internet se jerarquiza en \acrfull{AS}, que son redes muy grandes (en la mayoría de los casos, abarcan todo un país) gestionadas por una única autoridad.
\begin{observacion}
Cada \acrshort{AS} tiene un número único de $32$ bits que lo identifica. Por ejemplo, La Red Iris tiene el número \verb|AS766|.
\end{observacion}

De esta forma, cada \acrshort{AS} informará al resto de los demás \acrshort{AS} sobre las redes que tienen, de forma que compartirán su información de encaminamiento. Hay dos niveles de intercambio de tablas de encaminamiento:
\begin{itemize}
    \item Algoritmos \acrfull{IGP}: protocolos de intercambio de información de encaminamiento dentro de un mismo \acrshort{AS}. Cada autoridad tiene libertad de elección, y los más comunes son \acrshort{RIP}, \acrshort{OSPF}\ldots.

    \item Algoritmos \acrfull{EGP}: protocolo de intercambio de información de encaminamiento entre distintos \acrshort{AS}. Al ser estos distintas, se usa un único protocolo, \acrshort{BGP}.
\end{itemize}

\subsubsection{\acrfull{RIP}}

Aunque es una funcionalidad de la capa de red, se implementa sobre la capa de aplicación (opera sobre \acrshort{UDP} en el puerto 520), ya que la funcionalidad y la implementación son independientes.\\

Es un protocolo que adopta un algoritmo vector-distancia; es decir, se basa exclusivamente en el número de saltos, ignorando la velocidad de cada una de las conexiones. Una vez que un router aprende un camino para llegar a cierta red, no aprende otro a no ser que el número de saltos sea menor.\\

Cuando un router \acrshort{RIP} se enciende y es configurado, envía cada cierto tiempo (por defecto $\unit[30]{s}$) a todos los routers de sus respectivas redes un mensaje en el que informa de las redes a las que sabe llegar, junto con el coste que le supone para cada una de ellas. Además, recibirá de forma periódica la información correspondiente de los demás routers. Cuando un router recibe información de un vecino, si encuentra una ruta que no conocía, la añade a su tabla de encaminamiento, con el coste que le ha anunciado dicho vecino más $1$ (el salto al correspondiente vecino). En el resto de casos, tan solo si el coste es menor que el que ya tenía, se actualiza la entrada.\\

Toda esta información se comparte por la dirección multicast \verb|224.0.0.9|, en la que escuchan todos los routers que soportan \acrshort{RIP}.\\

\noindent\textbf{Problema de la cuenta al infinito}
\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=4cm]
        \node[router] (r1) {};
        \node[router, right of=r1] (r2) {};
        \node[router, right of=r2] (r3) {};

        % Bucle for para marcar los routers
        \foreach \i in {1,...,3} {
            \node[yshift=-0.8em] at (r\i) {\color{white} \textbf{R\i}};
        }

        \node[cloud, left of=r1] (cloud) {Red 1};

        % Conexiones
        \draw (cloud.east) -- (r1.west);
        \draw (r1.east) -- (r2.west);
        \draw (r2.east) -- (r3.west);

        % Rotura de la Conexion entre cloud y R1
        \draw[red, dashed, thick] ($(cloud.north) + (2,0.2)$) -- ($(cloud.south) + (2,-0.2)$);
    \end{tikzpicture}
    \caption{Problema de la cuenta al infinito en \acrshort{RIP}.}
    \label{fig:rip}
\end{figure}

Un problema que puede surgir al emplear \acrshort{RIP} es la convergencia lenta, ya que las malas noticias tardan en propagarse. Puede ocurrir que algún camino se rompa y, dada la naturaleza del protocolo, esta información tarda en notificarse.

Este se maximiza en el conocido ``problema de la cuenta al infinito'', que se muestra en la Figura~\ref{fig:rip}. En dicha figura podemos ver que, inicialmente, R1 tenía acceso a la red 1, aunque posteriormente dicho camino se rompe y R1 es notificado de que ha perdido acceso a dicha red. No obstante, R2, que aún no ha sido notificado de que ya no puede llegar a dicha red, al compartir a R1 su tabla de encaminamiento le informa de que él sí sabe llegar a la red 1, por lo que R1 lo aprende (aumentando en una unidad el coste), y así sucesivamente. Cuando R2 reciba la información del corte, aprenderá el camino por R1, y así sucesivamente. Esto podría llegar a repetirse indefinidamente (de ahí del nombre) hasta $16$ (ya que ese es el límite para \acrshort{RIP} en el que se asume que no se sabe llegar a dicha red), sin que ninguno en realidad supiese llegar a dicha red. Veamos algunas posibles soluciones:
\begin{description}
    \item [Split horizon:] Se basa en que a un router se le prohíbe compartir una ruta por la misma interfaz por la que la aprendió en primer lugar.
    
    De esta forma, R2 no podría enseñarle a R1 cómo llegar a la red 1, por lo que el problema no empieza a sucederse.
    \item [Hold down:] Retrasa los mensajes que nos llegan de una dirección que ya conocemos 180 segundos, esperando a que nos respondan los anteriores, si siguen activos. 
    \item [Poison reverse:] Si no sabemos llegar a un destino, informamos de que nuestro coste es infinito (coste $16$).
\end{description}

\subsubsection{\acrfull{OSPF}}

A diferencia de \acrshort{RIP} (que siempre consideraba el coste como el número de saltos), \acrshort{OSPF} es un protocolo que permite al administrador definir el coste en función de distintos aspectos (velocidad, latencia, etc.).
Como criterio por defecto, el coste de un enlace es el inverso del ancho de banda (la velocidad) de dicho enlace. Este protocolo busca el camino global que minimiza la suma de todos los costes, usando para ello el algoritmo de Dijkstra\footnote{Trata en la asignatura de Algorítmica}.\\

Permite definir áreas, de forma que la difusión se hace en unas áreas concretas. Esto hace que sea mucho más escalable, al contrario que \acrshort{RIP}.\\

\noindent
Los mensajes que se envían entre los routers que usan \acrshort{OSPF} son:
\begin{itemize}
    \item \verb|Hello|: mensaje empleado para establecer la conexión, en el que se avisa a los routers que se van a comunicar.
    \item \verb|Database description|: mensaje empleado para informar sobre la topología de las redes que conocemos. 
    \item \verb|Link status request|/\verb|update|/\verb|ack|: mensajes enviados para consultar, actualizar, o confirmar cambios.
\end{itemize}


\subsection{Cabecera \acrshort{IP}}

En la presente sección profundizaremos en la cabecera \acrshort{IP}, junto con sus campos. Esta se puede ver en la Tabla~\ref{tab:cabecera_ip}. Como vemos, está organizada en palabras de $32$ bits (4 Bytes), y como mínimo ocupa 20 Bytes (ya que el campo \textit{Opciones} es opcional, y el de \textit{relleno} se emplea para que sean múltiplos de 32 bits).
    \begin{table}
        \centering
        \begin{tabular}{|cccccccc|}
        \hline \rowcolor[HTML]{EFEFEF}
        \multicolumn{1}{|c|}{\cellcolor[HTML]{EFEFEF}\scriptsize{\textbf{0-3}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\scriptsize{\textbf{4-7}}} & \multicolumn{2}{c|}{\cellcolor[HTML]{EFEFEF}\scriptsize{\textbf{8-15}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\scriptsize{\textbf{16-18}}} & \multicolumn{3}{c|}{\cellcolor[HTML]{EFEFEF}\scriptsize{\textbf{19-31}}} \\ \hline \hline
        \multicolumn{1}{|c|}{V}            & \multicolumn{1}{c|}{LC}           & \multicolumn{2}{c|}{TS}            & \multicolumn{4}{c|}{Longitud Total}                                       \\ \hline
        \multicolumn{4}{|c|}{Identificador}                                                                         & \multicolumn{1}{c|}{I}          & \multicolumn{3}{c|}{Desplazamiento} \\ \hline
        \multicolumn{2}{|c|}{TTL}                                              & \multicolumn{2}{c|}{Protocolo}     & \multicolumn{4}{c|}{Checksum}                                             \\ \hline
        \multicolumn{8}{|c|}{Dirección IP de Origen}                                                                                                                                            \\ \hline
        \multicolumn{8}{|c|}{Dirección IP de Destino}                                                                                                                                           \\ \hline
        \multicolumn{5}{|c|}{Opciones}                                                                                                                    & \multicolumn{3}{c|}{Relleno}        \\ \hline
        \end{tabular}
        \caption{Cabecera \acrshort{IP}.}
        \label{tab:cabecera_ip}
    \end{table}

Veamos los campos, en orden, que la componen:
\begin{description}
    \item[Versión:] (4 bits) Indica la versión de \acrshort{IP} que se está utilizando. Contiene \verb|0100| si es \acrshort{IPv4} y \verb|0110| si es \acrshort{IPv6}.
    \item[Tamaño de cabecera:] (4 bits) Indica el tamaño de la cabecera en palabras de 32 bits. Su valor mínimo es de $5$ palabras ($20$ Bytes) y su máximo de $15$ palabras ($60$ Bytes).
    \item[Tipo de Servicio:] (8 bits) Indica la calidad de servicio deseada durante el tránsito del paquete por una red. Algunas redes ofrecen prioridades de servicios, considerando determinados tipos de paquetes más prioritarios que otros (especialmente cuando la carga de la red es alta).
    \item[Longitud total:] (16 bits) Indica el tamaño total, en bytes (también llamados octetos), del datagrama, incluyendo el tamaño de la cabecera y el de los datos.
    \item[Identificador:] (16 bits) Identificador único del datagrama. Se utiliza en caso de que el datagrama deba ser fragmentado, para poder distinguir los fragmentos de un datagrama de los de otro. Resaltamos por tanto que todos los fragmentos de un mismo datagrama tienen el mismo identificador.
    \item[Indicadores:] (3 bits) En la actualidad se utiliza para especificar valores relativos a la fragmentación. Los tres bits (por orden de mayor a menor peso) son:
    \begin{equation*}
        \begin{array}{|c|c|c|}
            \hline
            0 & \text{DF} & \text{MF} \\ \hline
        \end{array}
    \end{equation*}
    donde:
        \begin{itemize}
            \item Bit 0: Reservado, debe ser 0.
            \item Bit 1 (\acrfull{DF}): indica si el datagrama puede ser fragmentado (0) o no (1). Si un paquete necesita ser fragmentado para enviarse y este bit es 1, se descartará.
            \item Bit 2 (\acrfull{MF}): indica si el fragmento es el último (0) o si le siguen más fragmentos (1).
        \end{itemize}

    \item[Desplazamiento:] (13 bits) En paquetes fragmentados, indica la posición, en unidades de $\unit[64]{b}=\unit[8]{B}$, que ocupa dentro del datagrama original.
    
    \item[\acrfull{TTL}:] (8 bits) Indica el número de saltos máximo de un paquete en una red para evitar que los paquetes naveguen en la red indefinidamente. En cada salto, el campo se reduce en una unidad; y si este campo llega a 0, el paquete se descarta.
    
    \item[Protocolo:] (8 bits) Valor numérico que indica el protocolo de las capas superiores al que debe entregarse el paquete\footnote{Estos valores se pueden consultar \href{https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml}{\ul{aquí}}.}.
    
    \item[Checksum:] (16 bits) Es una comprobación de la corrección del datagrama. Se recalcula cada vez que algún nodo cambia alguno de sus campos (como el \acrshort{TTL}).
    
    El método de cálculo consiste en sumar en complemento a 1 cada palabra de 16 bits de la cabecera (considerando como $0$ el campo del \textit{checksum}) y hacer el complemento a 1 del valor resultante. Así, cuando llega al destino, se hace esta misma operación y se comprueba si es correcta la cabecera.

    \item[Dirección IP de origen:] (32 bits) Dirección IP del emisor del paquete.
    
    \item[Dirección IP de destino:] (32 bits) Dirección IP del destino del paquete.
    
    \item[Opciones:] (opcional) Campo que puede contener información adicional, como la ruta que ha seguido el paquete.
    
    \item[Relleno:] Este campo tiene tantos bits como sean necesarios para que la cabecera tenga un tamaño múltiplo de $\unit[32]{b}=\unit[4]{B}$.
\end{description}

\subsection{Fragmentación}

Como hemos visto en el aprtado anterior, el tamaño máximo de un paquete que se envíe usando el protocolo \acrshort{IP} es de $2^{16}-1$ Bytes, aunque este es un valor teórico que ninguna red suele aceptar. 
Dentro de una red, cada tarjeta de red tiene un \acrfull{MTU}, un valor numérico que indica el tamaño máximo de un paquete que se pasar a la capa de enlace para ser enviado por la red.\\

Como hemos mencionado, el \acrshort{MTU} depende del estándar de cada tarjeta de red. Algunos ejemplos son:
\begin{itemize}
    \item Ethernet: 1500 Bytes.
    \item Wifi: Aunque el valor es mayor, normalmente el \acrshort{SAP} lo restringe a 1500 Bytes.
\end{itemize}

Notemos que, en la cabecera \acrshort{IP} vista en la sección anterior, los campos de \textit{identificación}, \textit{desplazamiento} e \textit{Indicadores} son los que se usan para controlar la fragmentación.\\

Algunas observaciones importantes son:
\begin{itemize}
    \item Si hay algún error y no llegan todos los fragmentos de un datagrama se descarta todo y debe ser una capa superior la que se encargue de arreglar el problema.
    \item Un datagrama solo se fragmentará cuando vaya a pasar por una tarjeta de red con un \acrshort{MTU} menor que el tamaño del paquete. Esta fragmentación se hará cuando sea necesaria, y puede ser en cualquier nodo del encaminamiento.
    \item Los datagramas tan solo se podrán ensamblar en el destino, ya que distintos fragmentos podrán seguir caminos distintos, dependiendo del encaminamiento.
\end{itemize}

\begin{observacion}
    Es común hablar del \acrshort{MTU} de una red. Esto se dirá cuando las tarjetas de red de dicha red tengan el mismo valor \acrshort{MTU}.
\end{observacion}

\begin{ejemplo}\label{ejemplo:fragmentacion}
    \begin{figure}
        \centering
        \resizebox{\linewidth}{!}{
            \begin{tikzpicture}[node distance=5.5cm]
                \node[cloud] (redA) {\large{A}};
                \node[router, right of=redA, xshift=-2.5cm] (r1) {};
                \node[router, right of=r1] (r2) {};
                \node[router, right of=r2] (r3) {};
                \node[cloud, right of=r3, xshift=-2.5cm] (redB) {\large{B}};

                % Bucle for para marcar los routers
                \foreach \i in {1,...,3} {
                    \node[yshift=-0.8em] at (r\i) {\color{white} \textbf{R\i}};
                }

                % Conexiones
                \draw (redA.east) -- (r1.west);
                \draw (r1.east) -- node[midway, above]{$\text{MTU}_1=\unit[1500]{B}$} (r2.west);
                \draw (r2.east) -- node[midway, above]{$\text{MTU}_1=\unit[1000]{B}$}(r3.west);
                \draw (r3.east) -- (redB.west);
            \end{tikzpicture}
        }
        \caption{Red para el ejemplo de la Página~\pageref{ejemplo:fragmentacion}.}
        \label{fig:fragmentacion}
    \end{figure}

    Supongamos que queremos enviar un datagrama con $\unit[4180]{B}$ de datos desde la red A a la red B, según el diagrama de la Figura~\ref{fig:fragmentacion}. Supongamos que su identificador es $X$. Veamos si se produce fragmentación, y en qué paquetes se fragmenta.
    \begin{observacion}
        Recordemos que el campo de \emph{Fragmentación} mide en unidades de $\unit[8]{B}$, por lo que si un paquete se fragmenta, el tamaño de los fragmentos ha de ser múltiplo de $\unit[8]{B}$. No obstante, por simplificación en el ejemplo, supondremos que se mide en unidades de $\unit[1]{B}$ (aunque, reiteramos, no es lo que ocurriría en la realidad).
    \end{observacion}

    Como la cabecera ocupa $20$ Bytes, el tamaño a enviar es de $\unit[4200]{B}$. Este no se podrá enviar por la red que une R1 y R2, pues su \acrshort{MTU} es de $\unit[1500]{B}$. Por tanto, se fragmentará en R1. Veamos cada uno de los paquetes, teniendo en cuenta que de los $\unit[1500]{B}$ de límite, $20$ han de ser para la cabecera:
    \begin{enumerate}
        \item \ul{Paquete 1.} Faltan por enviar $\unit[4180]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 1480 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}
        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = 1,\qquad \text{Desplazamiento} = 0
        \end{equation*}

        \item \ul{Paquete 2.} Faltan por enviar $\unit[4180]{B}-\unit[1480]{B}=\unit[2700]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 1480 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}
        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = 1,\qquad \text{Desplazamiento} = 1480
        \end{equation*}

        \item \ul{Paquete 3.} Faltan por enviar $\unit[2700]{B}-\unit[1480]{B}=\unit[1220]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 1220 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}
        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = \red{0},\qquad \text{Desplazamiento} = 2960
        \end{equation*}
    \end{enumerate}

    Cuando cada uno de estos paquetes llegue a R2, como el \acrshort{MTU} de la red que lo conecta con R3 es de $\unit[1000]{B}$ y todos los paquetes tienen un tamaño mayor, se fragmentarán en R2. Veamos cada uno de los paquetes, teniendo en cuenta que de los $\unit[1000]{B}$ de límite, $20$ han de ser para la cabecera:
    \begin{enumerate}
        \item \ul{Paquete 1.1.} Faltan por enviar $\unit[1480]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 980 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}

        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = 1,\qquad \text{Desplazamiento} = 0
        \end{equation*}

        \item \ul{Paquete 1.2.} Faltan por enviar $\unit[1480]{B}-\unit[980]{B}=\unit[500]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 500 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}

        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = \red{1},\qquad \text{Desplazamiento} = 980
        \end{equation*}

        \item \ul{Paquete 2.1.} Faltan por enviar $\unit[1480]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 980 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}

        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = 1,\qquad \text{Desplazamiento} = 1480
        \end{equation*}

        \item \ul{Paquete 2.2.} Faltan por enviar $\unit[1480]{B}-\unit[980]{B}=\unit[500]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 500 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}

        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = \red{1},\qquad \text{Desplazamiento} = 2460
        \end{equation*}

        \item \ul{Paquete 3.1.} Faltan por enviar $\unit[1220]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 980 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}

        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = 1,\qquad \text{Desplazamiento} = 2960
        \end{equation*}

        \item \ul{Paquete 3.2.} Faltan por enviar $\unit[1220]{B}-\unit[980]{B}=\unit[240]{B}$ de datos, por lo que se envían:
        \begin{equation*}
            \begin{array}{|c|c|}
                \hline 20 & \hspace{1cm} 240 \hspace{1cm}~\\ \hline
            \end{array}
        \end{equation*}

        La cabecera IP de este paquete tendrá los campos:
        \begin{equation*}
            \text{Identificador} = X,\qquad \text{MF} = \red{0},\qquad \text{Desplazamiento} = 3940
        \end{equation*}
    \end{enumerate}

    Cuando cada uno de estos paquetes llegue a R3, este los reenviará a la IP de destino, dentro de la red B. Allí, se ensamblarán de vuelta los paquetes, obteniendo así el datagrama original.
\end{ejemplo}


\section{Asociación con la capa de enlace: \acrfull{ARP}}
Cuando queremos enviar un datagrama desde un origen a un destino, usando la tabla de encaminamiento del nodo en cuestión podemos saber la dirección IP del siguiente salto. No obstante, al bajar a la capa de enlace, ya no contemplamos direcciones IP\@, ya que el direccionamiento en esta capa se hace mediante direcciones \acrshort{MAC_red}. Además, debido a que el encaminamiento en la capa de enlace se hace punto a punto, las direcciones \acrshort{MAC_red} de origen y de destino cambian en cada salto.\\

Como hemos visto, sabemos las dirección IP de origen y la del siguiente salto, pero no la dirección \acrshort{MAC_red} del siguiente salto. Esto nos lo proporcionará el protocolo \acrshort{ARP}, que es un protocolo de la capa de enlace que se encarga de resolver direcciones \acrshort{MAC_red} a partir de direcciones IP\@.

\subsubsection{Funcionamiento}

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=5cm]
        \node[laptop] (l1) {};
        \node[laptop, right of=l1] (l2) {};

        % Bucle for para marcar los laptops
        \foreach \i in {1,2} {
            \node[xshift=0.6em, yshift=0.7em] at (l\i) {\color{white} \textbf{PC\i}};
        }

        % Conexion
        \draw (l1.east) -- (l2.west);
    \end{tikzpicture}
    \caption{Red para el funcionamiento de \acrshort{ARP}.}
    \label{fig:arp}
\end{figure}

Supongamos la situación de la Figura~\ref{fig:arp}, en la que PC1 quiere mandar un datagrama a PC2 (notemos que no consideramos intermedirarios, puesto que en el nivel de enlace el encaminamiento se hace punto a punto). El nodo PC1 conoce de sí mismo tanto su dirección IP como su dirección MAC\@, mientras que del siguiente salto (PC2) tan solo conoce la dirección IP tras haber consultado la tabla de encaminamiento. Para poder enviarle la trama\footnote{El datagrama ya se ha encapsulado en una trama, ya que en el nivel de enlace el \acrshort{PDU} se denomina trama.} a PC2, necesita saber la dirección MAC de PC2\@. Esto nos lo proporciona el protocolo \acrshort{ARP}, que funciona de la siguiente forma:
\begin{itemize}
    \item PC1 manda una petición \verb|ARP Request| a nivel de enlace por la dirección \verb|FF:FF:FF:FF:FF:FF| (la dirección de difusión a nivel de enlace), preguntando por la dirección MAC de la dirección IP de PC2.
    
    \item PC2, que habrá recibido dicha petición, identifica que la dirección IP de la petición es la suya, por lo que contesta con un mensaje \verb|ARP Reply| con su dirección MAC en unicast a PC1 (cuya dirección MAC ya conoce).
\end{itemize}

Este proceso no se hace (pues introduciría mucho tráfico) cada vez que se quiera mandar una trama, sino que las direcciones \acrshort{MAC_red} que recibimos se van guardando en una caché y, tras cierto tiempo, expiran.
\begin{observacion}
    Como curiosidad, para consultar dicha caché en un equipo con \verb|Linux| se puede emplear el comando \verb|arp -a|.
\end{observacion}

\subsection{Cabecera \acrshort{ARP}}

\begin{table}
    \centering
    \begin{tabular}{|cccc|}
    \hline \rowcolor[HTML]{EFEFEF}
    \multicolumn{1}{|c|}{\cellcolor[HTML]{EFEFEF}\qquad\scriptsize{\textbf{0-7}}\qquad~} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\qquad\scriptsize{\textbf{8-15}}\qquad~} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\qquad\scriptsize{\textbf{16-23}}\qquad~} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\qquad\scriptsize{\textbf{24-31}}\qquad~} \\ \hline \hline
    \multicolumn{2}{|c|}{Htipo}            & \multicolumn{2}{c|}{Ptipo} \\ \hline
    \multicolumn{1}{|c|}{Hlen}            &
    \multicolumn{1}{c|}{Plen}            & \multicolumn{2}{c|}{Operacion} \\ \hline
    \multicolumn{4}{|c|}{Hemisor (Bytes 0-3)} \\ \hline
    \multicolumn{2}{|c|}{Hemisor (Bytes 4-5)}            & \multicolumn{2}{c|}{Pemisor (Bytes 0-1)} \\ \hline
    \multicolumn{2}{|c|}{Pemisor (Bytes 2-3)}            & \multicolumn{2}{c|}{Hsol (Bytes 0-1)} \\ \hline
    \multicolumn{4}{|c|}{Hsol (Bytes 2-5)} \\ \hline
    \multicolumn{4}{|c|}{Psol (Bytes 0-3)} \\ \hline
    \end{tabular}
    \caption{Cabecera \acrshort{ARP}.}
    \label{tab:cabecera_arp}
\end{table}

La cabecera de una trama \acrshort{ARP} se muestra en la Tabla~\ref{tab:cabecera_arp}, donde notemos que ``H'' indica ``Hardware'' (capa de enlace) y ``P'' indica ``Protocol'' (capa de red). Los campos de dicha cabecera son:
\begin{description}
    \item[Htipo:] (2 Bytes) Número que indica el protocolo que se usa en el nivel de enlace (por ejemplo, Ethernet es \verb|1|).
    \item[Ptipo:] (2 Bytes) Número que indica el protocolo que se usa en el nivel de red (por ejemplo, \acrshort{IP} es \verb|0x0800|).
    \item[Hlen:] (1 Byte) Número que indica la longitud de la dirección hardware (en Bytes). Para direcciones \acrshort{MAC_red} es 6.
    \item[Plen:] (1 Byte) Número que indica la longitud de la dirección del protocolo de red (en Bytes). Para direcciones \acrshort{IPv4} es 4.
    \item[Operación:] (2 Bytes) Número que indica si es una petición o una respuesta. El valor \verb|1| indica \verb|Request| y el valor \verb|2| indica \verb|Reply|.
    \item[Hemisor:] (6 Bytes) Dirección hardware (normalmente MAC) del emisor.
    \item[Pemisor:] (4 Bytes) Dirección de red (normalmente IP) del emisor.
    \item[Hsol:] (6 Bytes) Dirección hardware (normalmente MAC) del receptor.
    \item[Psol:] (4 Bytes) Dirección de red (normalmente IP) del receptor.
\end{description}

Notemos por tanto que, en una petición, el campo de Hsol contendrá la direción \acrshort{MAC} de difusión, como hemos mencionado anteriormente.\\

Por último, destacar que el protocolo \acrshort{ARP} tiene su homólogo \acrfull{RARP} que hace lo contrario, es decir, dado una dirección \acrshort{MAC_red} nos devuelve su dirección IP\@. Cuando Internet comenzó, había equipos sencilos con pocas características, incluso sin disco duro. Al no tener disco duro, estos no podían almacenar su dirección IP, aunque las tarjetas de red si guardaban su dirección \acrshort{MAC_red}. Era por tanto necesario un protocolo que nos diera la dirección IP a partir de la dirección \acrshort{MAC_red}, y así nació el protocolo \acrshort{RARP}. En la actualidad se encuentra en desuso, pero fue el precursor de \acrshort{BOOTP}, el cual más tarde fue sustituido por \acrshort{DHCP}.

\section{El protocolo \acrshort{ICMP}}
El \acrfull{ICMP} es un protocolo que, aunque no es imprescindible, es de gran ayuda. En general, sirve para informar al origen de que ha habido un error. Este protocolo es útil pues, aunque \acrshort{IP} no arregla ningún tipo de problema, este protocolo informa para que las capas superiores decidan qué hacer. Este es un protocolo de nivel de red que se encapsula también en el nivel de red, en un datagrama \acrshort{IP}.\\

\subsection{Paquete \acrshort{ICMP}}

\begin{table}
    \centering
    \begin{tabular}{|ccc|}
    \hline \rowcolor[HTML]{EFEFEF}
    \multicolumn{1}{|c|}{\cellcolor[HTML]{EFEFEF}\qquad\scriptsize{\textbf{0-7}}\qquad~} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\qquad\scriptsize{\textbf{8-15}}\qquad~} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\qquad\scriptsize{\textbf{16-31}}\qquad~} \\ \hline \hline
    \multicolumn{1}{|c|}{Tipo}            & \multicolumn{1}{c|}{Código} & \multicolumn{1}{c|}{Comprobación} \\ \hline
    \end{tabular}
    \caption{Cabecera \acrshort{ICMP}.}
    \label{tab:cabecera_icmp}
\end{table}


La cabecera, que se muestra en la Tabla~\ref{tab:cabecera_icmp}, se compone de $32$ bits. Veamos cada uno de los campos que la componen:
\begin{description}
    \item[Tipo:] (1 Byte) Indica el tipo de mensaje que se está enviando. Los tipos más comunes se muestran en la Tabla~\ref{tab:tipos_icmp}.
    \item[Código:] (1 Byte) Para cada tipo de mensaje, indica el subtipo que se está enviando, para detallarlo aún más.
    \item[Comprobación:] (2 Bytes) Es un campo de checksum de la cabecera.
\end{description}
\begin{table}
\centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Tipo} & \textbf{Descripción} \\ \hline
        8/0 & Solicitud/Respuesta ``echo'' (\verb|ping|) \\
        3 & Destino inalcanzable \\
        4 & Ralentización del origen \\
        5 & Redireccionamiento \\ 
        11 & \acrshort{TTL} excedido \\
        12 & Problema de parámetros \\
        13/14 & Solicitud/Respuesta de sello de tiempo\\
        17/18 & Solicitud/Respuesta de máscara de red\\ \hline
    \end{tabular}
    \caption{Tipos de mensajes \acrshort{ICMP}.}
    \label{tab:tipos_icmp}
\end{table}

Respecto a la parte de datos, este paquete contiene los primeros 64 bytes del paquete que provocó el error. Es decir (suponiendo que la cabecera \acrshort{IP} no tiene campo de ``Opciones''), contiene los 20 Bytes de la cabecera \acrshort{IP} y los 44 Bytes de datos del paquete \acrshort{IP} que provocó el error. De esta forma, cuando el origen reciba este paquete podrá encontrar información sobre el paquete que provocó el error.\\

No debemos olvidar que \acrshort{ICMP} se encapsula sobre el protocolo \acrshort{IP}. Por tanto, el datagrama que se envía por la red (que es correcto) contiene una cabecera \acrshort{IP} y en el \acrshort{SDU} contiene el paquete \acrshort{ICMP}, que contiene su respectiva cabecera y, en la parte de datos, la cabecera \acrshort{IP} y los primeros 44 Bytes de datos del paquete que provocó el error. Por tanto, en el mismo datagrama se enviará tanto la cabecera del paquete \acrshort{IP} que provocó el error como la cabecera \acrshort{IP} que se envía encapsulando el mensaje \acrshort{ICMP} que informa del error.\\

Como aspectos relevantes, además de informar de errores nos permite conocer la situación de la red usando el comando \verb|ping|, que envía un paquete \acrshort{ICMP} de tipo ``echo'' (tipo 8) y espera una respuesta de tipo ``echo'' (tipo 0). Además, nos permite conocer la ruta que sigue un paquete usando el comando \verb|traceroute|, que envía paquetes \acrshort{ICMP} de tipo ``echo'' (tipo 8) con un \acrshort{TTL} creciente (1,2,...). De esta forma, en cada salto, un paquete excederá su \acrshort{TTL}, por lo que se enviará un mensaje \acrshort{ICMP} de tipo ``TTL excedido'' (tipo 11) que informará de que el paquete no ha podido llegar a su destino. Esto nos permitirá saber todos los nodos que se encuentran en la ruta que sigue el paquete.


\section{Autoconfiguración de la capa de red (\acrshort{DHCP})}

El \acrfull{DHCP} es un protocolo para configurar de forma automática la capa de red. Este protocolo se encarga de asignar direcciones IP, máscaras, pasarelas por defecto e IP del servidor \acrshort{DNS}. Su funcionalidad es a nivel de red, aunque se implementa en capa de aplicación y se encapsula en \acrshort{UDP} (puerto 67 para el servidor, 68 para el cliente).\\

Contamos con un cliente, que inicialmente no tiene dirección IP asignada (emplearemos la \verb|0.0.0.0|), y un servidor \acrshort{DHCP}, el cual se encargará de asignársela. Se trata de un protocolo de \textit{leasing} (alquiler), ya que la dirección IP que se asigna al cliente es válida durante un tiempo.\\

Para conseguir una dirección IP, se intercambian los siguientes mensajes entre el cliente y el servidor \acrshort{DHCP} (donde cada par pregunta-respuesta se etiqueta con un identificador de transacción para que el cliente sepa que el mensaje va para él):
\begin{itemize}
    \item \verb|DHCP Discover|: El cliente envía un mensaje para que saber si hay algún servidor \acrshort{DHCP} en la red. Lo envía por tanto a la dirección de difusión.
    \begin{align*}
        \text{Dirección IP origen} &= \texttt{0.0.0.0} \\
        \text{Dirección IP destino} &= \texttt{255.255.255.255} \\
        \text{ID transacción} &= X
    \end{align*}

    \item \verb|DHCP Offer|: El servidor responde identificándose y proponiéndole una dirección IP al cliente, que será válida durante cierto tiempo (\textit{lease time}), el cual se configura en el servidor \acrshort{DHCP}. Notemos que esto es solo una oferta, no una imperativa.
    
    Como el cliente aún no tiene dirección IP asignada, se envía de nuevo a la dirección de difusión.
    \begin{align*}
        \text{Dirección IP origen} &= \text{Dirección IP del servidor} \\
        \text{Dirección IP destino} &= \texttt{255.255.255.255} \\
        \text{ID transacción} &= X \\
        \text{Dirección IP ofrecida} &= Y \\
        \text{Lease time} &= \unit[Z]{s}
    \end{align*}
    \item \verb|DHCP Request|: El cliente le solicita al servidor la dirección IP que le ha ofrecido el servidor (o la misma que ya estaba usando, en el caso de que se trate de una renovación).
    
    Aunque ya no es necesario que se envíe a la dirección de difusión (ya que el cliente conoce la dirección IP del servidor \acrshort{DHCP} que le ha hecho la oferta), el estándar establece que se envíe aun así a la dirección de difusión (aunque permite ambas formas).
    \begin{align*}
        \text{Dirección IP origen} &= \texttt{0.0.0.0} \\
        \text{Dirección IP destino} &= \texttt{255.255.255.255} \\
        \text{ID transacción} &= X' \\
        \text{Dirección IP solicitada} &= Y \\
        \text{Lease time} &= \unit[Z]{s}
    \end{align*}
    \item \verb|DHCP ACK|: El servidor responde con la dirección IP del cliente definitiva, y esta sí es imperativa.
    
    De nuevo, en este caso el servidor se ve obligado a enviar a la dirección de difusión.
    \begin{align*}
        \text{Dirección IP origen} &= \text{Dirección IP del servidor} \\
        \text{Dirección IP destino} &= \texttt{255.255.255.255} \\
        \text{ID transacción} &= X' \\
        \text{Dirección IP asignada} &= Y \\
        \text{Lease time} &= \unit[Z]{s}
    \end{align*}
\end{itemize}

Como hemos mencionado, la IP de destino en toda la transacción es la de difusión, y la de origen es la \verb|0.0.0.0| en caso de ser el cliente el origen, o la del servidor \acrshort{DHCP} en caso de ser él el origen.\\

Por último, para liberar la dirección IP de forma correcta (sin que surja ningún error), el cliente debe enviar el mensaje \verb|DHCP Release| al servidor \acrshort{DHCP} antes de que termine el tiempo de alquiler. En caso contrario, el servidor liberará la IP igualmente, ya que es posible que el cliente ya no la esté usando y sea necesario liberarla para no quedarnos sin direcciones IPs disponibles. En el caso de que el cliente busque renovar su alquiler, volverá a enviará un mensaje \verb|DHCP Request| al servidor \acrshort{DHCP}.

\begin{observacion}
    Es posible configurar un servidor para que algunas IPs fijas se asignen a ciertos dispositivos.
\end{observacion}